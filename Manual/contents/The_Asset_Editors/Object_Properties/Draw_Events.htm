<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>События розыгрыша</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the draw event." />
  <meta name="rh-index-keywords" content="Objects - Draw Events" />
  <meta name="search-keywords" content="draw event,draw begin,draw end,pre-draw,post draw,draw GUI,draw order" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>События розыгрыша</h1>
  <p><img>Категория событий Draw - это категория, в которой собраны все события, определяющие то, что вы видите на экране при запуске игры. Она разделена на различные
    отдельные события, чтобы лучше справляться с различными требованиями к рисованию в вашей игре, и на рисунке ниже показан порядок выполнения каждого события:</p>
  <p><img>Обычное событие Draw подразделяется на три подтипа: <strong>Начало рисования</strong>, стандартное <strong>рисование</strong> и
   <strong>Draw End</strong>. В общем, вам понадобится использовать только стандартное событие Draw, и вы должны знать, что у всех экземпляров в комнате это событие будет срабатывать на каждом шаге игры, поэтому это событие будет вызываться всегда, пока
    пока у экземпляра флаг <strong>видимости </strong>установлен в true. Важно понимать, что даже если вы ничего не определили для этого под-события в свойствах объекта (т.е. нет ни кода, ни действий), <em>если объекту назначен <span class="notranslate">sprite</span>, у него все равно будет вызываться событие рисования</em>.
    Это происходит потому, что в <span data-keyref="GameMaker Name">GameMaker</span> есть два способа рисования объектов в событии Draw:</p>
  <ul class="colour">
    <li> <strong>рисование по умолчанию</strong>, то есть когда вы определяете <span class="notranslate">sprite</span> в свойствах объекта и не помещаете никаких действий или кода в обычное событие Draw, и в этом случае <span data-keyref="GameMaker Name">GameMaker</span> нарисует назначенный <span class="notranslate">sprite</span> автоматически. Обратите внимание, что любые преобразования
      которые вы выполняете в других событиях, чтобы изменить масштаб изображения, индекс, смешивание и т.д... будут также отражены, пока событие рисования пустое.</li>
    <li> <strong>пользовательское рисование</strong>, когда вы помещаете код или действия в событие рисования. Это говорит <span data-keyref="GameMaker Name">GameMaker</span>: &quot; <em>Я хочу управлять тем, что вы рисуете для экземпляров этого объекта</em>&quot;, и полностью отменяет стандартное
      рисование. Это означает, что, например, вы можете иметь объект с назначенным <span class="notranslate">sprite</span>, затем установить событие draw на draw text, и текст будет нарисован на экране, но <span class="notranslate">sprite</span> <em>не </em>будет нарисован, так как вы не сказали <span data-keyref="GameMaker Name">GameMaker</span> нарисовать его вместе с текстом.
      рисовать его вместе с текстом.</li>
  </ul>
  <p>Остальные события розыгрыша объясняются в разделах, перечисленных ниже:</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Начало рисования и конец рисования</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Помимо основного события Draw, у вас также есть события <strong> Draw Begin</strong> и <strong>Draw End</strong>. Они действуют точно так же, как и стандартные события Draw (т.е. они будут рисовать все, что вы поместите в них на каждом шаге игры и для
      но они не рисуют ничего &quot;по умолчанию&quot;, если они не были явно добавлены к объекту, и всегда выполняются до/после стандартного события Draw. Таким образом, когда игра запущена, у вас <em>всегда</em> будет событие
      событие Draw Begin для всех экземпляров, затем событие Draw для всех экземпляров, и, наконец, событие Draw End для всех экземпляров.</p>
    <p class="dropspot">Таким образом, вы можете рисовать объекты или устанавливать свойства рисования на шаге Draw Begin в одном экземпляре и быть уверенным, что все экземпляры со стандартным событием Draw или Draw End будут использовать эти свойства или рисовать поверх того, что нарисовал первый экземпляр. По сути,
      это надежный способ гарантировать, что определенные вещи будут нарисованы в определенное время, подобно тому, как это делают события <strong>Begin Step</strong> и <strong>End Step </strong>.</p>
    <p class="dropspot">Есть несколько моментов, на которые следует обратить внимание при рисовании в <span data-keyref="GameMaker Name">GameMaker</span>, будь то <span class="notranslate">sprite</span>, шейдер или 3D-буфер:</p>
    <ul class="colour">
      <li class="dropspot">Событие draw - это очень интенсивное событие, поскольку оно занимает больше всего времени и ресурсов... в связи с этим никогда не стоит делать в событии draw что-либо, кроме рисования. Поэтому приберегите свой большой код или сложные действия
        для события Step, Alarms или любого другого подходящего события, но оставьте событие draw для рисования, поскольку это то, что оно делает лучше всего.</li>
      <li class="dropspot">Если у вашего объекта параметр visible установлен в значение <em>off </em>(чтобы экземпляры объекта не рисовались), то <strong>все события рисования пропускаются </strong>(за исключением события <strong>Resize </strong>). Это означает, что если сделать экземпляр
        невидимым, остановит выполнение всего кода, размещенного в любом из этих событий, поэтому не размещайте важный код в событиях рисования, если они не будут видимыми.</li>
      <li class="dropspot">То, что вы рисуете, не имеет никакого отношения к выбранному вами механизму столкновений (традиционному или физическому), поскольку это определяется свойствами объекта и <span class="notranslate">sprite</span> (или маской), которую дали объекту.</li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Нарисовать графический интерфейс пользователя</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Тип события Draw GUI относится к категории Draw Event и специально разработан для рисования элементов <a class="glossterm" data-glossterm="GUI" href="#">GUI</a>, на которые не влияет масштаб или поворот камеры просмотра. Это означает, что вы
      что экземпляр может нарисовать все элементы вашего <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> или пользовательского интерфейса без необходимости основывать позиционирование элементов на положении экземпляра в комнате или положении
      текущего вида камеры.</p>
    <p class="dropspot">При рисовании в этом событии важно понимать, что координаты рисования не меняются даже при активных видах камеры, а (0,0) <em>всегда </em>является верхним левым углом либо поверхности приложения, либо дисплея (см.
      примечание в нижней части этого раздела), а ширина и высота по умолчанию составляют 1:1 с поверхностью приложения. Упорядочение глубины сохраняется между экземплярами на разных слоях (поэтому экземпляр на более высоком слое будет рисоваться под
      один на более низком слое), а также внутри самих событий, так как событие <strong>Draw GUI Begin</strong> сначала отрисовывается для всех экземпляров, затем стандартное событие <strong>Draw GUI</strong> отрисовывается для всех экземпляров поверх него, и, наконец, событие <strong>Draw Gui End </strong>
      срабатывает.</p>
    <p class="dropspot">Таким образом, вы можете рисовать объекты или устанавливать свойства рисования в Draw GUI Begin в одном экземпляре и быть уверенным, что все экземпляры со стандартным событием Draw GUI или Draw GUI End будут использовать эти свойства или рисовать поверх того, что нарисовал первый экземпляр. По сути,
      это надежный способ гарантировать, что определенные вещи будут нарисованы в определенное время, подобно тому, как это делают события <strong>Begin Step</strong> и <strong>End Step</strong>.</p>
    <p class="dropspot">Эти события также можно использовать вместе с обычными событиями Draw (на которые, как и на обычные, влияют положение, масштаб и вращение вида камеры). Если у вас нет события Draw Event, но есть событие Draw GUI Event, то <span data-keyref="GameMaker Name">GameMaker</span> все равно
      по умолчанию нарисует <span class="notranslate">sprite</span> для данного экземпляра (если он есть), как обычно.</p>
    <p class="dropspot">Что касается других событий рисования, события Draw GUI всегда будут рисоваться поверх всего, что нарисовано в обычных событиях рисования. Таким образом, если у вас есть экземпляр на нижнем слое с событием Draw GUI, он будет рисоваться поверх экземпляра, который находится на более высоком слое
      с обычным событием рисования. Если оба экземпляра имеют событие Draw GUI, то порядок слоев будет соблюден.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Это событие по умолчанию будет рисовать 1:1 с размером поверхности приложения, который обычно является размером комнаты или порта просмотра. Это означает, что если у вас включена <strong>коррекция соотношения сторон</strong> в опциях игры
      графический интерфейс не будет рисоваться поверх черных полос, которые &quot;обрамляют&quot; игру. Это поведение можно отключить с помощью функции <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm"><span style="font-size:14px;"> <span class="inline" style="font-size: 14px">display_set_gui_maximise()</span></span></a> функция,
      и вы также можете зафиксировать событие GUI определенного размера, который затем будет автоматически масштабироваться в соответствии с размерами дисплея или поверхности приложения с помощью функции <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm"><span class="inline" style="font-size: 14px">display_set_gui_size()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">До и после жеребьевки</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">События Pre Draw и Post Draw относятся к категории Draw Event. Однако, в отличие от других событий Draw, эти события рисуют <em>непосредственно </em>в <a class="glossterm" data-glossterm="буфер дисплея" href="#">буфер дисплея</a>, который будет иметь размер
      объединенного пространства экрана для всех видовых экранов, видимых в данный момент, <em>или </em>размер окна, если используется только один видовой экран или вообще не используется. Изображение ниже иллюстрирует это:</p>
    <p class="dropspot"><img>Таким образом, если вы используете события Pre или Post draw, вы рисуете в полноэкранную цель рендеринга (буфер дисплея), которая будет иметь
      тот же размер, что и окно, под которое подгоняются все видовые экраны. Если у вас нет активных видовых экранов, то вместо этого устанавливается размер самого окна.</p>
    <p class="dropspot">Событие Pre Draw запускается перед любым другим событием рисования, и в нем вы можете устанавливать значения, задавать свойства рисования и даже рисовать, не заботясь о видовых экранах или размере слоя GUI (размер слоя GUI может быть таким же, как экранный
      буфер, но это может быть и не так, поскольку вы можете установить разрешение GUI в коде).</p>
    <p class="dropspot">Стоит отметить, что это событие происходит <em>до того, как </em>буфер дисплея будет очищен для обычного рисования, а это значит, что если вы не отключите очистку вида в редакторе комнаты, то ничего из нарисованного в событии Pre Draw не будет видно, так как при
      первая отрисовка видового экрана очистит его. Если вы хотите иметь возможность видеть сквозь сами видовые экраны, или вы вообще не используете видовые экраны, то вам также следует установить цвет фона с альфа 0 в параметре <strong><a href="../Rooms.htm">Редактор комнат</a></strong>.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Если вы отключите эти опции, вы можете заметить нежелательные артефакты, рисуемые на экране при тестировании игры (например, &quot;следы&quot; от инстансов). Это происходит потому, что вы рисуете прямо поверх предыдущего кадра
      буфера дисплея без его очистки. Однако вы можете использовать <span class="inline" style="font-size: 14px"><a href="../../GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm">draw_clear_alpha()</a> </span>чтобы сделать это
      самостоятельно.</p>
    <p class="dropspot">Событие Post Draw запускается <em>после </em>всех стандартных событий рисования, но <em>перед </em>событиями Draw GUI. Как и событие Pre Draw, оно основано на размере буфера дисплея и размещается перед событиями Draw GUI, чтобы вы могли
      выполнять эффекты постобработки и другие вещи на весь экран просто и легко, не вмешиваясь в любые элементы <a class="glossterm" data-glossterm="HUD" href="#">HUD/</a> <a class="glossterm" data-glossterm="GUI" href="#">GUI</a>.
      которые могут присутствовать в вашей игре.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Изменение размера окна</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">Этот тип события относится к категории событий Draw Event, и хотя на самом деле он ничего не рисует, он реагирует на изменения в буфере дисплея - в частности, он предназначен для реагирования на изменение размера буфера дисплея UWP при
      игровое окно &quot;привязывается&quot;.</p>
    <p class="dropspot">На целевой платформе UWP важно уловить изменение размера буфера дисплея в результате &quot;привязки&quot; игрового окна (когда пользователь, например, перетаскивает окно в сторону дисплея). Это событие как раз и
      срабатывает при каждом изменении окна, позволяя вам добавлять сюда пользовательский код, который будет изменять размер представления или позиционировать элементы <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> по мере необходимости. Эта функция предоставляется как удобный
      чтобы избежать необходимости постоянно проверять код события.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Вы не можете рисовать в этом событии! Оно запускается при изменении размера окна и предназначено только для улавливания этого изменения... любое рисование, которое должно быть выполнено, должно быть выполнено в одном из других событий draw.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Object_Events.htm">События объекта</a></div>
        <div style="float:right">Следующий: <a href="Async_Events.htm">Асинхронные события</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Draw Events
Pre Draw Event
Post Draw Event
Draw Begin Event
Draw End Events
Draw GUI Events
Draw GUI Begin Event
Draw GUI End Event
Pre Draw Event
Post Draw Event
Window Resize Event
-->
  <!-- TAGS
draw_events
-->

</body></html>