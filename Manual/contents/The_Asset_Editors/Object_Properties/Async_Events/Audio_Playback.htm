<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Воспроизведение аудио</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the Audio Playback async event." />
  <meta name="rh-index-keywords" content="Objects - Async Audio Playback Event" />
  <meta name="search-keywords" content="Audio Playback,ev_audio_playback" />
  <link rel="stylesheet" type="text/css" href="../../../assets/css/default.css" />
  <script src="../../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Воспроизведение аудио</h1>
  <p><img>Это событие может быть вызвано только функциями воспроизведения <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/Audio_Buffers.htm">аудиоочереди</a> и возвращает <a href="../../../GameMaker_Language/GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">карту DS</a>, хранящуюся в переменной <a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm"> <span class="inline">async_load</span></a>,
    содержащую различные пары ключ/значение, относящиеся к аудиоочереди, которая вызвала событие. Событие запускается <a class="glossterm" data-glossterm="обратный звонок" href="#">обратным вызовом</a>, когда вы выбрали аудиоочередь для воспроизведения и
    буфер в этой аудиоочереди закончил воспроизведение.</p>
  <p>В карте DS будут доступны следующие клавиши:</p>
  <ul class="dropspotlist">
<<<<<<< HEAD
    <li class="dropspot">&quot;<span class="inline">queue_id</span>&quot; - индекс очереди, которая закончила воспроизведение, возвращаемый функцией <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_play_queue.htm"><span class="inline">audio_create_play_queue()</span></a>.</li>
    <li class="dropspot">&quot;<span class="inline">buffer_id</span>&quot; - идентификатор буфера, из <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">которого</a> прекращено воспроизведение.</li>
    <li class="dropspot">&quot;<span class="inline">queue_shutdown</span>&quot; - устанавливается на 0 при обычном воспроизведении и на 1, когда событие получено, потому что <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_free_play_queue.htm"><span class="inline">audio_free_play_queue()</span></a> был
      было вызвано. Когда это значение установлено в 1, вы не хотите ставить в очередь дальнейшие данные.</li>
  </ul>
  <p>Поскольку аудио очередь может быть создана из нескольких буферов, это событие может быть вызвано несколько раз для одной очереди по мере достижения конца каждой секции буферизованного аудио, отсюда и ключ &quot;buffer_id&quot;.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Переменная <span class="inline" style="font-size: 14px">async_load</span> действительна только в асинхронных событиях, поскольку карта DS, на которую она указывает, создается в начале события, а затем удаляется в конце, при этом данная переменная сбрасывается со значением -1.
    Однако все дальнейшие структуры данных, созданные в результате события, должны быть очищены с помощью соответствующих функций.</p>
  <p>В примере использования, приведенном ниже, мы создадим аудио очередь с 10 буферизованными аудио звуками, добавленными к ней, а затем воспроизведем очередь:</p>
  <p class="code">audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono);<br/> for (var i = 0; i &lt; 10; i++;)<br/>    {<br/>    audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));<br/>    }<br/> audio_play_sound(audio_queue,
    0, true);</p>
  <p>Теперь каждый шаг игры при обнаружении записи будет вызывать асинхронное событие Audio Recording, в котором вы сможете работать с записанным входом примерно так:</p>
  <p class="code">var queue = async_load[? &quot;queue_id&quot;];<br/> var num = 0;<br/> if queue = audio_queue<br/>    {<br/>    for (var i = 0; i &lt; 10; i++;)<br/>       {<br/>       if async_load[? &quot;buffer_id&quot;] == audio_buffer[i]<br/>          {<br/>  buffer_seek(audio_buffer[i],
    buffer_seek_start, 0);<br/>          num = i;<br/>          }<br/>       }<br/>    if num == 9<br/>       {<br/>       audio_stop_sound(audio_queue);<br/>       audio_free_play_queue(audio_queue);<br/>       }<br/>  }
  </p>
  <p>Здесь мы проверяем ID очереди, и если это та очередь, которая нам нужна, мы проверяем ID буфера, чтобы узнать, какой буфер закончил воспроизведение. Мы также устанавливаем локальную переменную в значение индекса для последующей проверки и возвращаем буфер в начало для этого звука.
    звука. Как только наша локальная переменная достигнет значения 9, что указывает на завершение очереди, мы остановим воспроизведение звука и освободим очередь.</p>
  <p> </p>
  <div class="droptext" data-targetname="drop-down"> </div>
  <p> </p>
  <p> </p>
=======
    <li class="dropspot">&quot;<span class="inline">queue_id</span>&quot; - the queue index for the queue that has finished playing, as returned by the function <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_play_queue.htm"><span class="inline">audio_create_play_queue()</span></a>.</li>
    <li class="dropspot">&quot;<span class="inline">buffer_id</span>&quot; - the <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">buffer</a> that is no longer being played from.</li>
    <li class="dropspot">&quot;<span class="inline">queue_shutdown</span>&quot; - this is set to 0 during normal playback and 1 when the event is received because <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_free_play_queue.htm"><span class="inline">audio_free_play_queue()</span></a> has been called. When this is set to 1, you don&#39;t want to queue up any further data.</li>
  </ul>
  <p>Since an audio queue can be created from multiple buffers, this event can be triggered multiple times for one queue as the end of each section of buffered audio is reached, hence the &quot;buffer_id&quot; key.</p>
  <p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"> </span> The variable <span class="inline2"><a data-xref="{title}" href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> is only valid in the asynchronous events, as the DS map that it points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of <span class="inline2">-1</span>. However, all further data structures created from the event must be cleaned up using the appropriate functions.</p>
  <p>In the example of use given below we will create an audio queue with 10 buffered audio sounds added to it and then play the queue:</p>
  <p class="code">audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono);<br />
    for (var i = 0; i &lt; 10; i++;)<br />
       {<br />
       audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));<br />
       }<br />
    audio_play_sound(audio_queue, 0, true);</p>
  <p>Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:</p>
  <p class="code">var queue = async_load[? &quot;queue_id&quot;];<br />
    var num = 0;<br />
    if queue == audio_queue<br />
       {<br />
       for (var i = 0; i &lt; 10; i++;)<br />
          {<br />
          if async_load[? &quot;buffer_id&quot;] == audio_buffer[i]<br />
             {<br />
             buffer_seek(audio_buffer[i], buffer_seek_start, 0);<br />
             num = i;<br />
             }<br />
          }<br />
       if num == 9<br />
          {<br />
          audio_stop_sound(audio_queue);<br />
          audio_free_play_queue(audio_queue);<br />
          }<br />
     }</p>
  <p>Here we check the queue ID and if it&#39;s the one we want, we then check the value in the &quot;buffer_id&quot; key to get the buffer that has finished playing. We also then set a local var to that index value for checking later and set the buffer back to the start for that sound. Once our local variable reaches 9, indicating that the queue has finished, we stop the sound playing and free the queue.</p>
  <p> </p>
  <p> </p>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="../Async_Events.htm">Асинхронные события</a></div>
        <div style="float:right">Следующий: <a href="Audio_Recording.htm">Аудиозапись</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Asynchronous Audio Playback Event
ev_audio_playback
Audio Playback
-->
  <!-- TAGS
ev_audio_playback
-->

</body></html>