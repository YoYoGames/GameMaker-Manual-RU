<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Руководство по использованию шейдеров</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Руководство по использованию шейдеров</h1>
  <p>Шейдеры часто используются для создания красивых графических эффектов в играх. Они также являются одними из самых продвинутых функций, предлагаемых <span data-keyref="GameMaker Name">GameMaker</span>, поэтому перед началом работы с ними необходимо иметь базовое понимание программирования и работы <span data-keyref="GameMaker Name">GameMaker</span>.</p>
  <p>Итак, что такое шейдер? Изначально они создавались для создания теней для освещения (отсюда и название), но сейчас они используются для создания огромного количества разнообразных эффектов. Код шейдера похож на обычный код, но он (почти всегда) выполняется GPU, а не CPU. Это отличие имеет свой набор правил и ограничений, но мы рассмотрим их позже.</p>
  <p>Каждый шейдер состоит из двух отдельных компонентов: <strong>вершинного шейдера </strong>и <strong>фрагментного шейдера </strong>(также называемого <strong>пиксельным шейдером</strong>). Начнем с вершинного шейдера. Каждый <span class="notranslate">sprite</span> образован прямоугольником, но компьютеры любят рисовать треугольники, поэтому прямоугольники разбиваются на два треугольника (иногда их называют <em>квадратами</em>). В результате у нас остается шесть вершин (углов) на каждый <span class="notranslate">sprite</span>, но две из них одинаковые, поэтому мы должны беспокоиться только о четырех. Теперь представьте, что у нас есть цикл for, который перебирает все вершины и выполняет код вершинного шейдера для каждой из них. Это позволяет нам изменить положение и цвет вершины перед передачей ее в шейдер фрагмента, поскольку шейдер вершины выполняется раньше.</p>
  <p>Вот как это будет выглядеть:</p>
  <p><img>Для фрагментного шейдера можно представить тот же цикл, что и раньше, но на этот раз он просматривает каждый отдельный пиксель в вашем <span class="notranslate">sprite</span>, предоставляя вам информацию, такую как местоположение и цвет этого пикселя. В коде фрагментного шейдера вы выполняете операции и вычисления для определения цвета пикселя, чтобы получить желаемый эффект. Например, если вы хотите, чтобы шейдер сделал ваш <span class="notranslate">sprite</span> черно-белым, то вы рассчитаете, какого оттенка серого должен быть каждый пиксель для создания эффекта.</p>
  <p>Это будет выглядеть примерно так:</p>
  <p><img>Причина, по которой шейдерный код обычно выполняется графическим процессором, заключается в том, что он более эффективен. Современные CPU обычно имеют от двух до восьми ядер. Каждое ядро может выполнять одну задачу за раз, поэтому, используя преимущества нескольких ядер, мы можем выполнять множество задач одновременно. В отличие от них, современные графические процессоры могут выполнять тысячи и даже десятки тысяч задач одновременно. Это полезно для шейдеров, поскольку мы можем одновременно выполнять код шейдера для тысяч пикселей. Ограничением является то, что мы имеем доступ только к начальному состоянию <span class="notranslate">sprite</span>, поэтому мы не знаем о любых модификациях, сделанных в других пикселях, так как мы не можем быть уверены, что код уже выполнялся на них.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: <span data-keyref="GameMaker Name">GameMaker</span> позволяет пользователям писать шейдеры на <strong>GLSL</strong> (OpenGL Shader Language), <strong>HLSL</strong> (High-level Shader Language, используется при работе с DirectX) и <strong>GLSL ES</strong> (подмножество GLSL, распространенное в мобильных устройствах). Здесь мы используем <strong>GLSL ES</strong> в качестве языка шейдеров, поскольку именно он обеспечивает наилучшую совместимость с целевыми платформами. Как правило, именно его вы всегда хотите использовать, если только у вас нет очень специфических потребностей и вы не понимаете ограничения других шейдерных языков. Математика и методы должны быть схожими для всех трех языков, за исключением некоторых различий в синтаксисе.</p>
  <p>Вершинный шейдер выполняется первым, и, как мы объясняли выше, он работает с <strong>вершинами</strong>. Он используется для вычисления положения, нормалей и координат текстуры. Эти шейдеры не особенно полезны в 2D, поскольку каждый <span class="notranslate">sprite</span> обычно является квадратом, но они могут быть использованы для некоторого перекоса, масштабирования и т.д.. Они становятся гораздо более полезными в 3D для расчетов освещения и деформации сетки. Фрагментные шейдеры гораздо интереснее и именно они будут рассматриваться здесь, поскольку именно фрагментный шейдер получает информацию о наших текстурах и может настраивать конечный цвет каждого пикселя в нашем изображении.</p>
  <p> </p>
  <h2>Переменные шейдера</h2>
  <p>Если вы создавали шейдер в <span data-keyref="GameMaker Name">GameMaker</span>, вы могли заметить следующие ключевые слова в стандартном <strong>проходном</strong> шейдере. Эти ключевые слова помогают шейдеру понять назначение и область применения каждой переменной:</p>
  <ul class="colour">
    <li><strong>Атрибут</strong>: Это переменные, передаваемые OpenGL <strong>вершинному </strong>шейдеру. Они могут изменяться для каждой вершины и доступны только для чтения. Они включают такую информацию, как положение вершины, координаты текстуры, цвет вершины и нормаль вершины.</li>
    <li><strong>Переменные</strong>: Это переменные, используемые для передачи данных между <strong>вершинным </strong>и <strong>фрагментным </strong>шейдерами. Они доступны для записи в вершинном шейдере, но доступны только для чтения во фрагментном шейдере.</li>
    <li><strong>Унифицированные</strong>: Это переменные, которые изменяются для каждого объекта и передаются шейдеру пользователем. Они могут использоваться как в вершинных, так и во фрагментных шейдерах, но доступны только для чтения.</li>
  </ul>
  <p>Вы также увидите использование <strong>vec</strong> в качестве ключевого слова. Оно используется для идентификации векторной переменной в шейдере, и вскоре вы увидите, что векторы очень важны при работе с шейдерами. Именно поэтому они реализованы как базовый тип в GLSL. Если вы не знакомы с ними, то это математический термин, представленный в виде матрицы с одним столбцом. В программировании мы обычно представляем их в виде массива, где количество компонентов соответствует размерности. Двухмерные и трехмерные векторы часто используются для позиций, координат текстур или цветов без альфа-канала, а четырехмерные - для цветов с альфа-каналом. Мы также можем указать, что они содержат булевы, целые числа или значения с плавающей запятой. Синтаксис для объявления вектора следующий:</p>
  <p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br />
    vec3 secondVec; // Three-dimensional vector of floats<br />
    vec4 thirdVec;  // Four-dimensional vector of floats<br />
    <br />
    bvec3 boolVec;  // Three-dimensional vector of booleans<br />
    ivec4 intVec;   // Four-dimensional vector of integers
  </p>
  <p>Чтобы инициализировать их, мы можем использовать конструктор для создания вектора. Вам нужно предоставить столько же значений, сколько длина вектора, но вы можете смешивать и сопоставлять скаляры и меньшие векторы, чтобы достичь целевой длины. Вот несколько примеров:</p>
  <p class="code">// Simple 2D vector with 2 scalar values<br />
    vec2 firstVec  = vec2(2.0, 1.0);<br />
    // A 4D vector using 2 scalars and a vec2 create the 4 values<br />
    vec4 secondVec = vec4(1.0, firstVec, 0.0);<br />
    // A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values<br />
    vec3 thirdVec  = vec3(secondVec.x, firstVec);</p>
  <p>Мы также можем присвоить им другой вектор той же длины (или <em>изменить </em>вектор до нужной длины, но об этом мы расскажем позже):</p>
  <p class="code">vec3 firstVec;<br />
    vec3 secondVec = firstVec;<br />
    vec4 thirdVec  = secondVec.xyz;<br />
    vec2 fourthVec = thirdVec.zx;</p>
  <p>При обращении к компонентам вектора в GLSL у нас есть несколько вариантов. Самый простой - рассматривать вектор как массив и обращаться к компонентам с помощью квадратных скобок, например, так:</p>
  <p class="code">vec4 myVec;<br />
    myVec[0] = 0.0;<br />
    myVec[1] = 1.0;<br />
    myVec[2] = 2.0;<br />
    myVec[3] = 1.0;</p>
  <p>Однако существует и другой способ доступа к компонентам со следующим синтаксисом:</p>
  <p class="code">vec4 myVec;<br />
    myVec.x = 1.0;<br />
    myVec.y = 2.0;</p>
  <p>Для доступа к ним используются имена компонентов внутри вектора. Вы можете использовать x, y, z или w, чтобы получить первый, второй, третий или четвертый компонент соответственно. Мы называем этот метод <strong>swizzling </strong>, потому что следующий синтаксис также допустим:</p>
  <p class="code">vec4 firstVec;<br />
    vec3 secondVec = firstVec.xyz;<br />
    vec2 thirdVec  = secondVec.zy;<br />
    vec4 fourthVec = thirdVec.yxxy;</p>
  <p>Как видите, мы можем использовать любую комбинацию до четырех букв для создания вектора такой длины. Мы не можем попытаться получить доступ к компоненту, который будет выходить за рамки (например, попытаться получить доступ к w в <span class="inline">secondVec</span> или <span class="inline">thirdVec</span>, поскольку у них нет четвертого компонента). Кроме того, мы можем повторять буквы и использовать их в любом порядке, при условии, что векторная переменная, которой она присваивается, имеет тот же размер, что и количество используемых букв.</p>
  <p>По очевидным причинам, при использовании swizzle для установки значений компонентов, вы не можете использовать один и тот же компонент дважды. Например, приведенный ниже вариант не подходит, так как вы пытаетесь установить один и тот же компонент на два разных значения:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>И последнее, мы использовали <span class="inline">xyzw</span> в качестве маски, что обычно происходит при работе с позициями. Есть еще два набора масок, которые вы можете использовать: <span class="inline">rgba</span> (используется для цветов) или <span class="inline">stpq</span> (используется для координат текстуры). Внутренне между этими масками нет никакой разницы, и мы используем их только для того, чтобы сделать код более понятным, что представляет собой вектор в данном случае. Кроме того, мы не можем комбинировать маски swizzle в одной операции, так что это недействительно:</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p>
  <p>Это было много определений и информации, но знание этих вещей необходимо для понимания самих шейдеров.</p>
  <p> </p>
  <h2>Создание шейдера</h2>
  <p>Когда вы создаете шейдер в <span data-keyref="GameMaker Name">GameMaker</span>, он открывает для вас два файла: вершинный шейдер (<span class="inline">.vsh</span>) и фрагментный шейдер (<span class="inline">.fsh</span>). Это самый простой шейдер, который вы можете создать. Он принимает файл <span class="notranslate">sprite</span>, считывает текстуру и окрашивает каждый пиксель в этот цвет. Если при рисовании вы укажете цвета вершин, эти цвета будут смешиваться с текстурой.</p>
  <p>Давайте пройдемся по коду только что созданного шейдерного актива и проанализируем его, начиная с вершинного шейдера.</p>
  <p class="code">// Passthrough Vertex Shader<br />
    attribute vec3 in_Position;                  // (x,y,z)<br />
    //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br />
    attribute vec4 in_Colour;                    // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;              // (u,v)<br />
    <br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br />
        gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br />
        <br />
        v_vColour = in_Colour;<br />
        v_vTexcoord = in_TextureCoord;<br />
    }
  </p>
  <p>За пределами главной функции мы видим некоторые объявления переменных и их классификаторы. Атрибуты даны нам <span class="notranslate">GameMaker</span>. Переменные создаются пользователем для передачи информации в шейдер фрагмента. Внутри основной функции мы имеем вычисления для определения экранной позиции вершины:</p>
  <ul class="colour">
    <li>Сначала мы создаем <span class="inline">vec4</span> и инициализируем его компонентами позиции, добавляя единицу в качестве четвертого компонента. В линейной алгебре принято добавлять единицу к четвертой компоненте, если вектор представляет точку, или ноль, если он представляет действительный вектор.</li>
    <li>Далее нам нужно добавить этот четвертый компонент, чтобы умножить его на матрицу <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, которая представляет собой матрицу 4x4. Это умножение спроецирует мировую позицию вершины на экранные координаты.</li>
    <li>Наконец, мы передаем цвет вершины и координаты текстуры в шейдер фрагмента через наши изменяемые переменные.</li>
  </ul>
  <p>Этот шейдер следует оставить в покое, если вы не планируете играть с позициями вершин, и он не будет использоваться ни в одном из примеров, приведенных ниже, потому что все показанные эффекты будут созданы с помощью шейдера фрагмента.</p>
  <p>Давайте теперь быстро посмотрим на шейдер фрагмента:</p>
  <p class="code">// Passthrough Fragment Shader<br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br />
    }
  </p>
  <p>Как уже объяснялось, идея фрагментного шейдера заключается в том, чтобы вернуть цвет текущего пикселя. Это делается путем присвоения переменной <span class="inline">gl_FragColor</span> конечного значения цвета. Функция <span class="inline">texture2D</span> принимает текстуру и <span class="inline">vec2</span> с UV-координатами, которые вы хотите проверить в этой текстуре, и возвращает <span class="inline">vec4</span> с цветом. В проходном шейдере все, что мы делаем, это берем цвет текстуры в координатах этого пикселя и умножаем его на цвет вершины, связанной с этим пикселем.</p>
  <p>Теперь, когда у нас есть наш первый шейдер, все, что нам нужно сделать для его тестирования, это создать объект и присвоить ему <span class="notranslate">sprite</span>, затем в <strong>событии Draw Event</strong> объекта установить шейдер следующим образом:</p>
  <p class="code">// Draw Event<br />
    shader_set(shdrColorOverlay);<br />
    draw_self();<br />
    shader_reset();</p>
  <p>Каждый ничейный вызов, который мы делаем между <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline">shader_set()</span></a> и <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline">shader_reset()</span></a> будет применяться шейдер. Здесь мы рисуем объект <span class="notranslate">sprite</span> с помощью нашего шейдера passthrough:</p>
  <p><img>Как вы уже догадались, визуально это ничего не меняет, поскольку это простой сквозной шейдер. Однако в следующих разделах описаны некоторые простые шаги, которые можно предпринять, чтобы изменить это и изменить способ отрисовки <span class="notranslate">sprite</span>. Каждый из разделов показывает различные шейдеры, которые вы можете создать и использовать в своих проектах, объясняя шаги, необходимые для их создания, и почему мы поступаем именно так.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Шейдер наложения цвета</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Теперь мы можем отредактировать базовый шейдер, чтобы сделать кое-что другое. Мы не будем касаться вершинного шейдера, а отредактируем только шейдер фрагмента, и для начала выполним очень простую операцию, которая заключается в том, чтобы заставить шейдер рисовать <span class="notranslate">sprite</span> красным цветом. Мы сделаем это, просто изменив <span class="inline">gl_FragColor</span> на красный цвет, вот так:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      void main()<br />
      {<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br />
      }</p>
    <p class="dropspot">Это даст нам следующий результат:</p>
    <p class="dropspot"><img>Не совсем то, что мы ожидали! Нам нужно помнить, что каждый <span class="notranslate">sprite</span> в конечном итоге является прямоугольником, поэтому, если не учитывать прозрачность - а мы этого не делали, - мы получим именно такой результат.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: На изображении выше прямоугольник меняет размер, потому что базовый <span class="notranslate">sprite</span> имеет &quot;пустое&quot; пространство вокруг него, которое было автоматически обрезано, когда он был помещен на страницу текстуры <span class="notranslate">GameMaker</span>, поэтому в каждом кадре анимации треугольники, составляющие его, имеют разные размеры, чтобы соответствовать обрезанному размеру кадра. Если отключить эту опцию, то на экране будет просто неподвижный красный квадрат.</p>
    <p class="dropspot">Выше мы упоминали функцию <span class="inline">texture2D</span>, и мы будем использовать ее для захвата цвета в пикселе, над которым мы работаем, и получения из него прозрачности. Возвращаемое значение функции <span class="inline">texture2D</span> - это <span class="inline">vec4</span>, где компонентами являются красный, зеленый, синий и альфа-канал, в таком порядке. Мы можем получить доступ к альфа-каналу, поставив точку, а затем <span class="inline">a</span> или <span class="inline">w</span> после имени переменной. Это соответствует RGBA и XYZW, соответственно.</p>
    <p class="dropspot">Вот обновленный код:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Теперь мы назначаем новый <span class="inline">vec4</span> на <span class="inline">gl_FragColor</span>, где красный канал максимален, зеленый и синий каналы равны нулю, а альфа-канал такой же, как у исходной текстуры. Результат выглядит следующим образом:</p>
    <p class="dropspot"><img>Это то, чего мы добивались! Мы заменили цвет каждого пикселя на красный, но сохранили альфа-канал нетронутым.</p>
    <p class="dropspot">Менять шейдер каждый раз, когда мы хотим использовать другой цвет, - не самая лучшая идея, особенно если учесть, что для каждого цвета нам потребуется отдельный шейдер. Вместо этого мы передадим шейдеру информацию о цвете с помощью <strong>формы</strong>. Для этого нам сначала нужно получить <strong>указатель </strong>на форму. Мы сделаем это в <strong>событии Create</strong> нашего объекта <span class="notranslate">sprite</span>, добавив:</p>
    <p class="code">// Create Event<br />
      _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br />
      _color    = [1.0, 1.0, 0.0, 1.0];</p>
    <p class="dropspot">Все, что нам нужно сделать, это вызвать <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a> чтобы получить указатель на форму. Параметры, которые нам нужно передать, это имя актива шейдера (без кавычек, потому что мы хотим передать ID, который <span class="notranslate">GameMaker</span> генерирует для нас) и имя переменной униформы внутри шейдера, на этот раз в виде строки. Это имя должно точно совпадать с именем в коде шейдера, чтобы он работал. Мы также добавили переменную color, чтобы мы могли изменять ее во время выполнения и чтобы она запомнила наши изменения.</p>
    <p class="dropspot">Теперь код в нашем событии draw немного изменится, чтобы передать переменную uniform.</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrColorOverlay);<br />
      shader_set_uniform_f_array(_uniColor, _color);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Это тот же код, что и раньше, но прежде чем мы нарисуем что-либо, нам нужно передать шейдеру все однородные значения. В данном случае мы передаем цвет как массив плавающих значений. Что касается шейдера, мы изменим его, чтобы он включал униформу и использовал ее, так что он становится:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      uniform vec4 u_color;<br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(u_color.rgb, texColor.a);<br />
      }</p>
    <p class="dropspot">Мы объявляем переменную с тем же именем, что и в шейдере create (<span class="inline">u_color</span>), и передаем ее в качестве первых трех компонентов вектора <span class="inline">gl_FragColor</span>, используя преимущества swizzling. Если мы скомпилируем еще раз, то увидим следующее:</p>
    <p class="dropspot"><img>Теперь шейдер стал гораздо более полезным и многократно используемым. Вы можете добавить больше функциональности, если вам нужно, чтобы он устанавливал цвет (используя переменную <span class="inline">_color</span>) во время выполнения.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Черно-белый шейдер</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Создание черно-белого шейдера - отличный способ узнать больше о том, как работают шейдеры, и многие новички начинают с попытки сделать это, поскольку концептуально это довольно просто: получить каждый пиксель и присвоить ему оттенок серого. Но так ли это просто? Не совсем...</p>
    <p class="dropspot">При использовании цвета RGB, если все три компонента имеют одинаковое значение, то мы получаем серый тон. Наивный подход к созданию шейдера для использования этой идеи заключался бы в том, чтобы сложить все три цветовых канала (красный, зеленый и синий), а затем разделить на три. После этого вы присвоили бы это значение всем трем каналам, создав таким образом серый тон. Вот как выглядит шейдер фрагмента:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br />
          gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Вы могли заметить, что в коде <span class="inline">gl_FragColor</span> мы умножаем <span class="inline">vec4</span> на что-то под названием <span class="inline">v_vColour</span>. Это переменная, передаваемая вершинным шейдером, которая сообщает нам цвет вершины, связанной с этим пикселем. Всегда полезно умножать конечный вычисленный цвет на цвет вершины. В большинстве случаев это ничего не даст, но если вы изменили цвет вершины в <span class="notranslate">GML</span>, это отразится (с помощью таких функций, как <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> или <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> для изменения <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Что касается события draw, то оно довольно простое, поскольку у нас нет формы для передачи:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrBlackAndWhite);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Давайте скомпилируем и посмотрим, что у нас получилось.</p>
    <p class="dropspot"><img>Это уже выглядит отлично, верно? И да, и нет... есть решение, которое является более "правильным", поскольку вместо сложения компонентов и деления на три мы умножаем каждый компонент на стандартные значения NTSC для черного и белого. Вот измененный код фрагментного шейдера:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br />
          gl_FragColor = vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Мы используем точечное произведение как сокращение для умножения каждого компонента <span class="inline">texColor</span> с правильными весами, а затем складываем их вместе. Если вы не знакомы с точечным произведением, то, по сути, происходит следующее:</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p>
    <p class="dropspot">В конечном итоге, это выглядит очень похоже, но технически более правильно.</p>
    <p class="dropspot"><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Радужный шейдер</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Наш последний пример шейдера - это забавный пример, который можно использовать для придания жизни тексту, кнопкам и другим вещам. Мы начнем с простого и будем постепенно добавлять функциональность, поскольку этот шейдер очень настраиваемый. В этом разделе мы рассмотрим довольно много вопросов, поэтому если вы чувствуете себя немного потерянным или запутавшимся, пожалуйста, вернитесь и перечитайте некоторые разделы выше.</p>
    <p class="dropspot">Первое, что мы хотим сделать, - это окрасить пиксели в любой оттенок в зависимости от горизонтального положения пикселя. Для этого нужно установить позицию x в качестве оттенка, а затем преобразовать формат HSV (оттенок, насыщенность, яркость) в формат RGB (красный, зеленый и синий). Для этого нам нужно написать вспомогательную функцию в шейдере фрагмента, которая принимает значения HSV и возвращает вектор RGB. Мы будем использовать одну функцию, которая делает это без необходимости использования каких-либо операторов <span class="inline">if</span>, так как использование условий в коде шейдера делает шейдеры <em>очень </em>медленными, и их следует избегать.</p>
    <p class="dropspot">Вот как выглядит шейдер на данном этапе:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Здесь происходит немного больше событий, чем в предыдущих примерах, но большинство из них должно быть достаточно очевидным для вас. Во-первых, есть наша функция <span class="inline">hsv2rgb</span>, которая принимает <span class="inline">vec3</span> с нашим цветом HSV и возвращает другой <span class="inline">vec3</span> с нашим преобразованием в RGB. В основной функции мы начинаем с создания цвета HSV, где оттенок - это наша позиция x, а насыщенность и яркость мы пока оставим равными 1.0. Затем мы получим альфу из текстуры, чтобы она окрасила только наш персонаж <span class="notranslate">sprite</span>, а не весь прямоугольник <span class="notranslate">sprite</span> (как мы делали в примере наложения цветов выше). Наконец, мы установим цвет фрагмента как цвет HSV, преобразованный в RGB с альфой, умноженной на цвет вершины (хорошая практика - делать это всегда).</p>
    <p class="dropspot">Что касается нашего кода для рисования, то на данный момент он тривиален:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Давайте проверим, что мы получили:</p>
    <p class="dropspot"><img>Мы близки к тому, что хотим, но есть проблема: мы не видим все цвета сразу в каждом кадре анимации, и цвета, кажется, меняются случайным образом. Причина в том, что мы предположили, что <span class="inline">v_vTexcoord</span> дал нам координаты <span class="notranslate">sprite</span>, начинающиеся в левом верхнем углу (0,0) и заканчивающиеся в правом нижнем углу (1,1), что является стандартным в шейдерах. Однако для оптимизации <span class="notranslate">GameMaker</span> запихивает столько текстур вместе, сколько может поместиться в так называемую <a href="../Settings/Texture_Information/Texture_Pages.htm">текстурную страницу,</a> и поэтому наша текстура выглядит именно так:</p>
    <p class="dropspot"><img>Как объяснялось выше, <span class="inline">v_vTexcoord</span> дает нам абсолютные координаты <span class="notranslate">sprite</span> на всей странице текстуры, но нам нужно значение от 0,0 до 1,0, которое охватывает только наш текущий <span class="notranslate">sprite</span>. Этот процесс называется <strong>нормализацией</strong> (получение значения и перевод его в диапазон от 0 до 1). Чтобы нормализовать наши горизонтальные значения, нам нужно знать значения x0 и x1 на рисунке выше. К счастью, в <span class="notranslate">GameMaker</span> есть функция, которая дает нам расположение каждого угла в нашем <span class="notranslate">sprite</span> на странице текстуры. Сначала нам нужно перейти в Create Event и создать форму для передачи этих данных шейдеру:</p>
    <p class="code">// Create Event<br />
      _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">И мы изменяем событие draw, чтобы получить значения и затем передать их шейдеру:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Функция <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> принимает <span class="notranslate">sprite</span> и индекс, и возвращает массив с массой информации, такой как координаты каждого угла, сколько пикселей было обрезано для оптимизации и т.д.. Нас интересуют два из этих значений: левая и правая координаты <span class="notranslate">sprite</span>, которые хранятся в <span class="inline">uv[0]</span> и <span class="inline">uv[2]</span> соответственно. В шейдере фрагмента мы будем использовать эти значения для вычисления нормализованного горизонтального положения следующим образом:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3(pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Здесь мы добавляем переменную uniform в верхней части файла с тем же именем, которое мы использовали в событии Create Event. Далее мы вычисляем нормализованную горизонтальную позицию, переводя нашу текущую координату <span class="inline">x</span> в начало координат ( <span class="inline">v_vTexcoord.x - u_uv[0]</span>), а затем делим ее на ширину <span class="notranslate">sprite</span>, чтобы получить диапазон от 0 до 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">В результате:</p>
    <p class="dropspot"><img>Вот так! Это именно то, что мы хотели. Мы можем видеть каждый цвет спектра внутри нашего <span class="notranslate">sprite</span>.</p>
    <p class="dropspot">Вы можете быть довольны этим, но мы можем еще немного поразвлечься с этим шейдером. Что если мы добавим смещение цветов, основанное на времени, чтобы создать движение? Для этого нам понадобятся две дополнительные переменные для <strong>скорости </strong>и <strong>времени</strong>. Нам также понадобятся еще две формы, по одной для каждой из новых переменных, так что событие Create Event станет:</p>
    <p class="code">// Create Event<br />
      _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _time  = 0;<br />
      _speed = 1.0;</p>
    <p class="dropspot">Нам также необходимо увеличивать время на каждом кадре, поэтому в событии Step Event мы добавляем:</p>
    <p class="code">// Step Event<br />
      _time += 1 / room_speed;</p>
    <p class="dropspot">Давайте теперь перейдем к событию draw, чтобы отправить эти формы в шейдер:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Наконец, мы вернемся к нашему шейдеру, чтобы фактически использовать эти переменные. Мы умножим скорость на время и добавим это к положению, как показано ниже:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Если вы все сделали правильно, вы должны увидеть что-то вроде этого:</p>
    <p class="dropspot"><img>Чтобы завершить этот шейдер, мы добавим еще несколько форм для его дальнейшей настройки. Первые две предназначены для управления насыщенностью и яркостью. Следующую мы назовем &quot;section&quot;, и ее функция - позволить пользователю передать число от нуля до единицы, чтобы определить, какой процент всего спектра мы видим за один раз. Наконец, мы добавим переменную &quot;mix&quot;, которая будет определять, насколько мы хотим смешать цвет нашего шейдера с цветом оригинальной текстуры (1.0 - вся радуга, 0.0 - вся текстура). Как обычно, начнем с добавления переменных в событие Create Event:</p>
    <p class="code">// Create Event<br />
      _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _uniSection    = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br />
      _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br />
      _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br />
      _uniMix        = shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br />
      <br />
      _time  = 0;<br />
      _speed = 1.0;<br />
      _section = 0.5;<br />
      _saturation = 0.7;<br />
      _brightness = 0.8;<br />
      _mix = 0.5;
    </p>
    <p class="dropspot">В ходе жеребьевки мы меняем униформу таким образом:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      shader_set_uniform_f(_uniSaturation, _saturation);<br />
      shader_set_uniform_f(_uniBrightness, _brightness);<br />
      shader_set_uniform_f(_uniSection, _section);<br />
      shader_set_uniform_f(_uniMix, _mix);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Что касается шейдера, нам нужно передать насыщенность и яркость в цвет, что повлияет на цвет, генерируемый нашей вспомогательной функцией. Сечение нужно умножить на нашу позицию, чтобы уменьшить диапазон. Мы также захватим весь цвет текстуры, чтобы вычислить наш окончательный цвет путем смешивания цвета текстуры с RGB-преобразованием нашего цвета. Последний параметр функции mix определяет, сколько второго цвета мы хотим добавить. Это наш окончательный код шейдера:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      uniform float u_saturation;<br />
      uniform float u_brightness;<br />
      uniform float u_section;<br />
      Uniform float u_mix;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          <br />
          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br />
        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br />
          <br />
          gl_FragColor = v_vColour * finalCol;<br />
      }
    </p>
    <p class="dropspot">И наш конечный результат таков!</p>
    <p class="dropspot"><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>На этом мы заканчиваем это краткое руководство, и теперь вы должны лучше понимать, как работают шейдеры и как их можно использовать. Не торопитесь играть с шейдерами, которые вы создали, следуя этому руководству, и попробуйте поэкспериментировать с ними для других целей - как насчет создания шейдера размытия или шейдера, который делает монохромный экран в стиле Gameboy? - поскольку шейдеры - это невероятно мощный инструмент для добавления визуальной сложности и стиля в ваши игры.</p>
  <p class="note">Мы хотели бы поблагодарить <a href="https://twitter.com/AleHitti">Алехандро Хитти</a> и компанию <strong>Amazon</strong> за разрешение воспроизвести это руководство. Оригинальную версию можно найти в <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">блоге разработчиков Amazon</a>.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующий: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Руководство по примитивам и построению вершин</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>