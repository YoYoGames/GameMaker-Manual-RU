<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<<<<<<< HEAD
  <title>Руководство по примитивам и построению вершин</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
=======
  <title>Guide To Primitives And Vertex Building</title>
  <meta name="generator" content="Adobe RoboHelp 2022" />
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use primitives and vertex buffers" />
  <meta name="rh-index-keywords" content="Guide To Primitives And Vertex Building" />
  <meta name="search-keywords" content="primitive building,primitives,vertex,vertex buffers,vertex formats" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
<<<<<<< HEAD
  <h1>Руководство по примитивам и построению вершин</h1>
  <p>Это руководство кратко описывает, как создавать и использовать <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">примитивы</a>, используя пользовательские <strong>форматы вершин</strong> и <strong>вершинные буферы</strong>. </p>
  <p>Обычно, когда вы начинаете работать с 3D, спецэффектами, сложными процессами рисования или шейдерами, вам не нужно слишком беспокоиться об используемом формате вершин, поскольку <span data-keyref="GameMaker Name">GameMaker</span> автоматически установит и передаст <a class="glossterm" data-glossterm="вершина" href="#">вершинные</a> данные за вас. Однако иногда необходимо создать собственные вершинные данные и отформатировать их в соответствии с требованиями, особенно если вам нужно увеличить скорость или передать дополнительную информацию. Например, стандартный формат вершин включает x, y, z 3D позицию, цвет (с альфой) и UV координаты текстуры, которые, если бы вы создавали их самостоятельно, выглядели бы примерно так:</p>
=======
  <h1><span data-field="title" data-format="default">Guide To Primitives And Vertex Building</span></h1>
  <p>This guide briefly covers how to build and use <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">primitives</a> using custom <strong>vertex formats</strong> and <strong>vertex buffers</strong>.</p>
  <p>In general when you start working with 3D, special effects, complex drawing processes or shaders you don&#39;t need to worry too much about the vertex format being used, since <span data-keyref="GameMaker Name">GameMaker</span> will automatically set up and pass through the <a class="glossterm" data-glossterm="vertex" href="#">vertex</a> data for you. However, sometimes it is necessary to create your own vertex data and format it to suit, especially when you need to boost speed, or wish to pass in extra information. For example the standard vertex format includes an x, y, z 3D position, colour (with alpha), and UV texture coordinates, which, if you were creating it yourself, would look something like this: </p>
  <h4 id="passthrough_vertex_format">Passthrough Vertex Format:</h4>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <p class="code">vertex_format_begin();<br />
    vertex_format_add_position_3d();<br />
    vertex_format_add_colour();<br />
    vertex_format_add_textcoord();<br />
    my_format = vertex_format_end();</p>
<<<<<<< HEAD
  <p>Однако если вы используете (например) шейдер только для манипулирования положением вершины, то нет необходимости передавать данные цвета или текстуры. В этом случае вы создадите свой собственный формат следующим образом:</p>
=======
  <p>However, if you are only using (for example) a shader to manipulate the position of the vertex, then there would be no need to pass through colour or texture data. In this case you would create your own format as follows: </p>
  <h4>Custom Vertex Format:</h4>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <p class="code">vertex_format_begin();<br />
    vertex_format_add_position_3d();<br />
    my_format = vertex_format_end();</p>
  <p>Всего существует пять различных атрибутов вершин, которые можно использовать при определении формата вершин:</p>
  <ul class="colour">
    <li>Цвет</li>
    <li>Нормальный</li>
    <li>Позиция</li>
    <li>Положение 3D</li>
    <li>Координата текстуры</li>
  </ul>
<<<<<<< HEAD
  <p>В общем случае вы <em>всегда</em> должны указывать позицию или 3D-позицию как часть формата, но все остальные параметры являются необязательными.</p>
  <p>Следует отметить, что после создания формата вершин, порядок, в котором вы определили атрибуты вершин, <i>должен соблюдаться</i> при создании <strong>примитивов</strong>. Так, если вы определили формат вершины как позицию, цвет и координату текстуры, то <b>вы <i>должны</i></b> добавить эти атрибуты в примитив в том же порядке, иначе вы получите ошибку. Также обратите внимание, что, как и любой другой динамический ресурс, формат вершины требует памяти и поэтому должен быть удален, когда он не нужен, с помощью функции<a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_delete.htm"><span class="inline">vertex_format_delete()</span></a>.</p>
  <p>Все примитивы, которые вы создаете, хранятся в <b>буфере вершин</b>. Он должен быть создан заранее, а затем на него ссылаются функции, которые используются для создания вашего примитива. Буфер вершин можно использовать повторно столько раз, сколько необходимо для создания различных примитивов, или его можно &quot;заморозить&quot;, чтобы сохранить определенный тип примитива на все время игры или уровня (это самый быстрый подход, поэтому если вы знаете, что созданный вами примитив не изменится, всегда используйте этот вариант).</p>
  <p>Пример построения примитива с одним треугольником показан в следующем коде:</p>
  <p class="code">// CREATE EVENT<br />
    v_buff = vertex_create_buffer();<br />
=======
  <p>In general you must <em>always</em> provide position or 3D position as part of the format, but all the others are optional.</p>
  <p>You should note that once you have created your vertex format, the order in which you have defined the vertex attributes <i>must be honoured</i> when building your <strong>primitives</strong>. So, if you have defined a vertex format as position, colour, and texture coordinate, then <b>you <i>must</i> add these attributes to the primitive in the same order otherwise you will get an error</b>. Also note that like any other dynamic resource, a vertex format requires memory and therefore should be removed when not needed using the function <span class="inline3_func"><a data-xref="{title}" href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_delete.htm">vertex_format_delete</a></span>.</p>
  <p>Any primitives that you build are held in a <b>vertex buffer</b>. This must be created beforehand and then referenced by the functions that are used to build your primitive. The vertex buffer can be reused as many times as necessary to create different primitives, or it can be &quot;frozen&quot; to maintain a specific primitive type for the duration of your game or level (which is the fastest approach, so if you know that a primitive you build will not change then you should always use this option).</p>
  <p>An example of a single triangle primitive being built is shown in the following code:</p>
  <p class="code_heading">Create Event</p>
  <p class="code">v_buff = vertex_create_buffer();<br />
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
    vertex_begin(v_buff, global.my_format);<br />
    vertex_position(v_buff, 10, 10);<br />
    vertex_colour(v_buff, c_white, 1);<br />
    vertex_texcoord(v_buff, 0, 0);<br />
    vertex_position(v_buff, 110, 10);<br />
    vertex_colour(v_buff, c_white, 1);<br />
    vertex_texcoord(v_buff, 1, 0);<br />
    vertex_position(v_buff, 110, 110);<br />
    vertex_colour(v_buff, c_white, 1);<br />
    vertex_texcoord(v_buff, 1, 1);<br />
    vertex_end(v_buff);</p>
  <p class="code_heading">Draw Event</p>
  <p class="code"><br />
    var tex = sprite_get_texture(spr_Background, 0);<br />
    shader_set(shd_shimmer);<br />
    vertex_submit(v_buff, pr_trianglelist, tex);<br />
<<<<<<< HEAD
    shader_reset();
  </p>
  <p>Здесь мы сначала создаем буфер вершин в событии Create экземпляра, затем начинаем определение различных вершин, составляющих наш треугольный примитив, указывая положение, цвет и UV-координаты текстуры для каждой из трех точек, которые мы хотим использовать. Затем мы завершаем определение вершин и узнаем, что буфер вершин с данными вершин хранится в переменной &quot;v_buff&quot;.  </p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Если содержимое буфера будет постоянно обновляться, буфер будет создан, ему будут переданы данные вершин, а затем он будет снова уничтожен - после того, как будет отрисован - и все это на одном шаге.</p>
  <p>Затем мы отрисовываем содержимое буфера вершин в событии Draw Event с помощью шейдера. Это очень простой пример, и в основном он показывает, как работает <span data-keyref="GameMaker Name">GameMaker</span> внутри программы, т.е.: когда вы рисуете <span class="notranslate">sprite</span>, <span class="notranslate">GameMaker</span> создает вершинный буфер с четырьмя вершинами, образующими два треугольника (которые образуют квадрат, также называемый &quot;квад&quot;), и текстурирует эти два треугольника изображением <span class="notranslate">sprite</span>. Когда мы рисуем этот <span class="notranslate">sprite</span>, мы передаем вершинный буфер, и его содержимое выводится на экран.</p>
  <p>Вы заметите, что когда мы передаем буфер вершин для отрисовки, мы предоставляем тип примитива. Тип используемого примитива может быть точкой, списком или полосой линий, списком или полосой треугольников, но вы <i>не</i> можете использовать веер треугольников, так как большинство мобильных устройств не принимают этот тип примитива. Не забудьте правильно отформатировать вершинный буфер для типа примитива, который будет использоваться для его отрисовки. Например, для рисования примитива с двумя треугольниками в виде списка треугольников требуется 6 точек, а в виде полосы треугольников - только 4 точки. Какой тип использовать - решать вам, это зависит от того, что вы хотите нарисовать, и от эффекта, которого вы хотите добиться.</p>
  <p>Последний важный момент, который следует отметить при использовании собственных вершинных буферов таким образом, - это то, как это влияет на пакеты вершин, которые отправляются на GPU. Когда вы создаете вершинный буфер, вы создаете самый низкий уровень графических данных, поэтому при рисовании все, что происходит, это то, что <span data-keyref="GameMaker Name">GameMaker</span> отправляет ваш буфер непосредственно на видеокарту. Поэтому, если вы хотите улучшить пакетную обработку, вы должны сделать это самостоятельно и хранить то, что вы хотите пакетно обрабатывать, в одном и том же буфере.</p>
  <p>Как мы уже говорили выше, вершинные форматы строятся с помощью следующих 5 типов атрибутов (добавляются с помощью соответствующей функции <span class="inline">vertex_format_add_*</span> ):</p>
=======
    shader_reset();</p>
  <p>Here we have first created our vertex buffer in the Create Event of the instance, then we begin the definition of the different vertices that make up our triangle primitive, giving the position, the colour, and the texture UV coordinate for each of the three points that we want to use. We then end the vertex definition, and we know that the vertex buffer with this vertex data is stored in the variable &quot;v_buff&quot;.  </p>
  <p class="note"><span data-conref="../assets/snippets/Tag_note.hts"> </span> If the contents of the vertex buffer are going to be updated constantly, it would be created, given the vertex data, and then be destroyed again - after it&#39;s been drawn - all in the same step.</p>
  <p>We then draw the contents of the vertex buffer in the Draw Event using a shader. This is a very simple example, and is basically how <span data-keyref="GameMaker Name">GameMaker</span> works internally, i.e.: When you draw a sprite, <span data-keyref="GameMaker Name">GameMaker</span> creates a vertex buffer with four vertices creating two triangles (which make a square, also called a &quot;quad&quot;), and textures these two triangles with the sprite image. When we draw this sprite, we are submitting the vertex buffer which draws its contents to the screen.</p>
  <p>You&#39;ll notice when we submit the vertex buffer for drawing, we supply a primitive type. The type of primitive you use can be a point, a line list or strip, or a triangle list or strip, but you are <i>not</i> permitted triangle fans since most mobile hardware will not accept that primitive type. Don&#39;t forget to format your vertex buffer correctly for the type of primitive that is going to be used to draw it. For example, drawing a two triangle primitive as a triangle list requires 6 points, but as a triangle strip it only requires 4 points. Which type you use is up to you and will depend on what you want to draw and the effect that you want to achieve.</p>
  <p>One final important point to note when using your own vertex buffers in this way is how it affects the vertex batches that are sent to the GPU. When you create a vertex buffer you are creating the lowest level of graphics data, so when you draw all that happens is that <span data-keyref="GameMaker Name">GameMaker</span> sends your buffer directly to the graphics card. Because of this, if you want better batching, you must work it out yourself and store the things you want to batch inside the same buffer.</p>
  <p>As we have already mentioned above, vertex formats are built up by using together the following 5 attribute types (added via the appropriate <span class="inline3_func">vertex_format_add_*</span> function):</p>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <ul class="colour">
    <li>Цвет</li>
    <li>Нормальный</li>
    <li>Позиция</li>
    <li>3D-позиция</li>
    <li>Координата текстуры</li>
  </ul>
  <p>В шейдере GLSL ES эти виды распознаются с помощью следующих 4 атрибутов:</p>
  <ul class="colour">
    <li>Цвет</li>
    <li>Нормальный</li>
    <li>Позиция</li>
    <li>Координата текстуры</li>
  </ul>
  <p>Теперь это может показаться странным, поскольку кажется, что мы можем указать больше видов атрибутов в нашем вершинном формате, чем в вершинном шейдере. Однако в шейдере <i>Position</i> и <i>3D Position</i> рассматриваются как один и тот <em>же </em>атрибут, за исключением того, что <i>Position</i>, как ожидается, имеет только координаты &quot;x&quot; и &quot;y&quot;, тогда как <i>3D Position</i> имеет координаты &quot;x&quot;, &quot;y&quot; и &quot;z&quot;. Как же сопоставить то, что находится в формате вершин, с тем, как вы определяете атрибуты в шейдере? Давайте начнем с рассмотрения типичного набора атрибутов из шейдера по умолчанию:</p>
  <p> </p>
  <p class="code">attribute vec3 in_Position;        // (x,y,z)<br />
    //attribute vec3 in_Normal;        // (x,y,z) unused in this shader.<br />
    attribute vec4 in_Colour;          // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;    // (u,v)</p>
  <p>А вот фрагмент кода, который устанавливает формат вершин, совместимый с этим шейдером:</p>
  <p class="code">vertex_format_begin();<br />
    vertex_format_add_position_3d();<br />
    vertex_format_add_colour();<br />
    vertex_format_add_textcoord();<br />
    my_format = vertex_format_end();</p>
  <p>Итак, как атрибут шейдера сопоставляется с типом вершинного формата? Это просто основано на соглашении об именовании:</p>
  <ul class="colour">
    <li><span class="inline">&quot;in_Position&quot;</span> карты на <span class="inline"><a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_position.htm">vertex_format_add_position</a>/<a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_position_3d.htm">_3d()</a></span></li>
    <li><span class="inline">&quot;in_Colour&quot;</span> карты на <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_colour.htm"><span class="inline">vertex_format_add_colour()</span></a></li>
    <li><span class="inline">&quot;in_TextureCoord&quot;</span> карты на <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_texcoord.htm"><span class="inline">vertex_format_add_texcoord()</span></a></li>
  </ul>
  <p><span class="inline"><span class="inline"><span class="inline"></span> Теперь все становится сложнее, когда у вас есть несколько атрибутов одного типа, но все равно все основано на одном и том же соглашении об именовании. Теперь мы рассмотрим предоставление дополнительных <b>координат</b> <b>цвета</b> и <b>текстуры</b>, поскольку в шейдере или вершинном формате может быть только <b>один</b> атрибут Position и <b>один</b> Normal, но <em>может</em> быть несколько атрибутов цвета или текстуры.</p>
  <p>При добавлении дополнительных цветовых атрибутов в шейдер к концу атрибута шейдера необходимо добавить число, указывающее, к какой именно записи вершинного формата относится атрибут. Вот пример - сначала формат вершин:</p>
  <p class="code">vertex_format_begin();<br />
    vertex_format_add_position_3d();<br />
    vertex_format_add_colour();<br />
    vertex_format_add_colour();<br />
    vertex_format_add_textcoord();<br />
    my_format = vertex_format_end();</p>
  <p>А теперь связанные атрибуты шейдера:</p>
  <p class="code">attribute vec3 in_Position;      // (x,y,z)<br />
    attribute vec4 in_Colour0;       // (r,g,b,a)<br />
    attribute vec4 in_Colour1;       // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;  // (u,v)</p>
<<<<<<< HEAD
  <p>В этом случае <span class="inline">in_Colour0</span> сопоставляется с первым <span class="inline">vertex_format_add_colour()</span>, а <span class="inline">in_Colour1</span> - со вторым.</p>
  <p>Координаты текстуры обрабатываются несколько иначе, чем цвет. В основном, все, что не называется <span class="inline">in_Position</span>, <span class="inline">in_Normal</span> или одним из атрибутов <span class="inline">in_Colour[0 ... ]</span>, рассматривается как текстурная координата. Порядок, в котором они определены в списке атрибутов в шейдере, обозначает, с каким атрибутом в формате вершин они связаны. Смотрите следующий пример <span class="notranslate">GML</span>:</p>
=======
  <p>In this case <span class="inline">in_Colour0</span> maps to the first <span class="inline">vertex_format_add_colour()</span> and <span class="inline">in_Colour1</span> maps to the second.</p>
  <p>Texture coordinates are handled slightly differently to colour. Basically, anything which isn&#39;t called <span class="inline">in_Position</span>, <span class="inline">in_Normal</span> or one of the <span class="inline">in_Colour[0 ... ]</span> attributes is treated as a texture coordinate. The order they are defined in, in the list of attributes in the shader, is what denotes which attribute in the vertex format they map to. See the following <span data-keyref="GML_Code">GML Code</span> example:</p>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <p class="code">vertex_format_begin();<br />
    vertex_format_add_position_3d();<br />
    vertex_format_add_colour();<br />
    vertex_format_add_textcoord();<br />
    vertex_format_add_textcoord();<br />
    vertex_format_add_textcoord();<br />
    my_format = vertex_format_end();</p>
  <p>А код шейдера будет выглядеть примерно так:</p>
  <p class="code">attribute vec3 in_Position;      // (x,y,z)<br />
    attribute vec4 in_Colour;        // (r,g,b,a)<br />
    attribute vec2 in_myTexcoord;    // (u,v)<br />
    attribute vec2 in_TextureCoord;  // (u,v)<br />
    attribute vec2 in_Something;     // (u,v)</p>
  <p>В этом примере <span class="inline">in_myTexcoord</span>, <span class="inline">in_TextureCoord</span> и <span class="inline">in_Something</span> отображаются на три последовательных атрибута текстурных координат, определенных в вершинном формате.</p>
  <p>Полный список всех функций, необходимых для создания вершинных форматов, вершинных буферов и примитивов, можно найти на следующей странице:</p>
  <ul class="colour">
    <li><a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Примитивы и форматы вершин</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующее: <a href="Guide_To_Using_Blendmodes.htm">Руководство по использованию блендмодов</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Primitive Building
Vertex Formats
Vertex Buffers
-->
  <!-- TAGS
using_primitives_vertex_buffers
-->
</body>
</html>