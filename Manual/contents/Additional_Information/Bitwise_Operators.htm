<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Побитовые операторы</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how bitwise operators work" />
  <meta name="rh-index-keywords" content="Bitwise Operators" />
  <meta name="search-keywords" content="bitwise,bitwise operators" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Побитовые операторы и двоичные</h1>
  <p>В начале компьютерной эры <strong>двоичная</strong> и <strong>шестнадцатеричная</strong> системы были образом жизни, вероятно, потому, что языки высокого уровня (такие как BASIC) были слишком медленными для работы. Например, для выполнения умножения 32 x 32 на BASIC могло потребоваться несколько тактов процессора, а в двоичной системе это делается как одна операция за один такт процессора.</p>
  <p>Однако в наши дни, с мощностью даже базового ПК, вам больше не нужно беспокоиться об этом, и вы можете делать все &quot;длинным путем&quot;, поскольку скорость машины и ее более сложная конструкция процессора компенсируют все недостатки такого подхода. Конечно, это отличная новость, поскольку она означает, что вам больше не придется оптимизировать каждую строчку написанного кода, но если это так - стоит ли вообще заботиться о двоичном коде?</p>
  <p>Ответ определенно &quot;да, стоит&quot;. Хотя это правда, что вы все еще можете получить некоторое увеличение скорости - и иногда оно может быть значительным - использование двоичных и шестнадцатеричных кодов приводит к лучшему пониманию того, как работает процессор, а также может привести к написанию лучшего кода, возможности лучше упаковывать данные и значительно упростить некоторые задачи. На этой странице мы немного расскажем о том, что такое двоичный код, а также о том, как его можно использовать при создании игр.</p>
  <p>Итак, давайте сначала рассмотрим самую основную теорию двоичных чисел - как создаются числа. Взгляните на эту таблицу:</p>
  <p class="code">000 = 0<br />
    001 = 1<br />
    010 = 2<br />
    100 = 4</p>
  <p>Каждая 1 или 0 представляет собой один <a class="glossterm" data-glossterm="бит" href="#">бит</a> данных, и, как вы видите, это означает, что в двоичном формате 10 равно 2! Каждый бит в 2 раза больше предыдущего значения, причем первый бит равен 1. Таким образом, бит 2 = 2, бит 3 = 4, бит 4 = 8 и так далее (как показано ниже в таблице <a class="glossterm" data-glossterm="байт" href="#">байтов</a> ):</p>
  <p class="code">00000001 = 1<br />
    00000010 = 2<br />
    00000100 = 4<br />
    00001000 = 8<br />
    00010000 = 16<br />
    00100000 = 32<br />
    01000000 = 64<br />
    10000000 = 128</p>
  <p>Это хорошо, если вам нужны числа, равные степени 2, но как создать более сложные числа? Одно двоичное число может хранить только 0 или 1, и все, поэтому для создания более сложных чисел нам нужно складывать биты вместе. Если, например, мы хотим получить число 6, то сложим 4 и 2 следующим образом.</p>
  <p class="code">00000010 = 2<br />
    00000100 = 4<br />
    00000110 = 6</p>
  <p>Это относится ко <strong>всем двоичным </strong>числам и к тому, как компьютер составляет любое число внутри себя. В качестве примера возьмем более сложное число: 23. Число 23 на самом деле состоит из <span class="inline">1+2+4+16</span> или <span class="inline">00010111</span>. А как насчет гораздо более сложного примера: 196? Ну, оно состоит из <span class="inline">128+64+4</span> или <span class="inline">11000100</span>. Так что на самом деле оно не такое уж и сложное!</p>
  <p>Если мы начинаем использовать значения вне диапазона байта (который может хранить числа от 0 до 255), отследить их становится немного сложнее. Например, 217 361 - это <span class="inline">110101000100010001</span> в двоичном формате. Или <span class="inline">1+16+256+etc...</span> Правила одинаковы независимо от того, какое значение выражается - каждое число создается путем сложения нескольких битов.</p>
  <p>Теперь, как нам выполнить математические операции над этими значениями? Допустим, вы хотите сохранить <span class="inline">true</span> или <span class="inline">false</span> в качестве значения. Обычно компиляторы используют <span class="inline">INT</span> ( <span class="inline">INT</span> обычно определяется как знаковое 32-битное число - знаковое означает, что оно может быть положительным или отрицательным, а беззнаковое - только положительным) и затем просто присваивают его <span class="inline">0</span> или <span class="inline">1</span>. Имея только 2 состояния, значение <span class="inline">true</span> / <span class="inline">false</span> идеально хранить в бите, и если мы сделаем это, то сможем хранить 32 бита <span class="inline">true</span> / <span class="inline">false</span> для каждого <span class="inline">INT</span>, а не один, поскольку <span class="inline">INT</span> состоит из 32 битов.</p>
  <p>Как бы мы это сделали? Оказывается, довольно просто:</p>
  <p class="code">flags = flags | 1;</p>
  <p>Оператор &quot;<span class="inline">|</span>&quot; является побитовым <span class="inline">OR</span>, и это означает, что приведенная выше инструкция <span class="inline">ORs</span> 1 в значение, хранящееся в переменной <span class="inline">flags</span>. Если вы помните из предыдущего, использование 1 устанавливает первый бит. Если бы мы хотели установить второй бит, мы бы сделали следующее:</p>
  <p class="code">flags = flags | 2;</p>
  <p>Мы <span class="inline">OR</span> в 2, потому что битовый шаблон <span class="inline">00000010</span> равен 2. Что же именно делает двоичный оператор <span class="inline">OR</span>? Ну, он объединяет все биты в одно значение, вот так:</p>
  <p class="code">010110100 // Value 1<br />
    110011001 // value 2<br />
    110111101 // Value 1 OR Value 2</p>
  <p>Вот что известно как <a class="glossterm" data-glossterm="таблица истинности" href="#">таблица истинности</a> для оператора OR:</p>
  <p class="code">00 | 00 = 00<br />
    00 | 01 = 01<br />
    01 | 01 = 01<br />
    01 | 00 = 01</p>
  <p>Поэтому там, где есть значение с двумя нулями, оно останется нулем. Преимущество использования таких битов в качестве <span class="inline">true</span>/<span class="inline">false</span> состояния заключается в том, что вы можете установить несколько битов в качестве &quot;флагов&quot; за одну операцию, чего вы просто не сможете сделать с обычным булевым значением. Например, допустим, бит 1 - это &quot;активный&quot; флаг, а бит 3 - &quot;видимый&quot; флаг. Мы можем установить оба флага следующим образом:</p>
  <p class="code">flags = flags | 5<span class="inline"></span>;</p>
  <p>Это происходит потому, что 5 - это <span class="inline">00000101</span> в двоичном формате, и, следуя вышеприведенному правилу, переменная &quot;flags&quot; получит оба этих бита, объединенных с ее собственными. Таким образом, даже если бит 1 уже был установлен, операция все равно сработает, и бит 3 также будет установлен.</p>
  <p>А как насчет очистки флагов? Вот тут-то и приходит на помощь побитовая операция &quot;<span class="inline">&amp;</span>&quot; <span class="inline">AND</span>. Когда вы <span class="inline">AND</span> что-то делаете, биты, установленные в маске, сохраняются, а биты, очищенные в маске, удаляются - вот так:</p>
  <p class="code">01110010101 // Value 1<br />
    00110000100 // Value 2<br />
    00110000100 // Value 1 AND value 2</p>
  <p>Как вы видите, там, где в каждом значении есть 1, 1 сохраняется, а там, где есть смесь 0 и 1, они сбрасываются в 0. Вот таблица истинности для <span class="inline">AND</span>ing:</p>
  <p class="code">00 &amp; 00 = 00<br />
    01 &amp; 00 = 00<br />
    00 &amp; 01 = 00<br />
    01 &amp; 01 = 01</p>
  <p>Таким образом, только когда в каждом месте есть бит, он будет сохранен. Это означает, что так же, как вы можете установить несколько флагов одновременно, вы можете и очистить несколько флагов одновременно. Например, возьмем приведенный выше случай, но на этот раз очистим их. Мы хотим очистить биты 1 и 3 (получив значение 5), но, вспоминая таблицу истинности выше, мы хотим оставить все остальные биты, а биты 1 и 3 очистить. Это будет двоичная &quot;маска&quot; 111111111111111111111111111111111010 (32 бита). Эта маска сохраняет все биты установленными, но очищает два бита, которые мы хотим очистить. Таким образом, если значение 1000111011 и я хочу очистить биты 1 и 3, используя вышеуказанную маску, это будет выглядеть следующим образом...</p>
  <p class="code">00000000000000000000001000111011 // Value<br />
    11111111111111111111111111111010 // Mask<br />
    00000000000000000000001000111010 // Value AND Mask</p>
  <p>Это здорово, но если бы нам приходилось делать это каждый раз, когда нам нужно очистить флаги, это стало бы утомительным. Нам нужен способ легко перебрасывать биты (и желательно без затрат процессора). К счастью, есть простой способ сделать это с помощью оператора &quot; <span class="inline">~</span>&quot; <span class="inline">NOT</span>.</p>
  <p>Оператор <span class="inline">NOT</span> - это именно то, что он говорит - <em>не</em> эти биты. Вот таблица истинности для <span class="inline">NOT</span>.</p>
  <p class="code">~00 = 11<br />
    ~01 = 10<br />
    ~10 = 01<br />
    ~11 = 00</p>
  <p>Этот оператор делает удаление флагов очень простым, и что еще лучше, обычно это оптимизация во время компиляции, то есть если вы используете постоянное число (то есть не переменную), то компилятор автоматически перевернет биты. Возьмем это выражение, где мы хотим снова очистить биты 1 и 3:</p>
  <p class="code">a = a &amp; ~5;</p>
  <p>На самом деле это будет компилироваться просто как &quot;<span class="inline">a &amp; 11111111111111111111111111111010</span>&quot;. Это делает жизнь довольно простой в плане очистки флагов.</p>
  <p>Последний оператор, который мы хотим рассмотреть, это &quot;<span class="inline">^</span>&quot; <span class="inline">EOR</span> (<span class="inline">Exclusive OR</span>, иногда называемый <span class="inline">XOR</span>), этот оператор переворачивает биты, установленные в обоих значениях. Вот таблица истинности <span class="inline">EOR</span>:</p>
  <p class="code">0 ^ 0 = 0<br />
    0 ^ 1 = 1<br />
    1 ^ 0 = 1<br />
    1 ^ 1 = 0</p>
  <p>Это любопытная, но невероятно полезная функция. Например, допустим, нам нужен счетчик, который просто считает от 0 до 1 и обратно до 0 (переключаясь между 0 и 1), мы можем добавить 1 и сделать <span class="inline">IF</span>, чтобы увидеть, дошел ли он до 2, а затем сбросить его обратно в 1. Или... мы можем добавить 1 и затем <span class="inline">AND</span> его с 1 (так как <span class="inline">01+01 = 10</span>, и <span class="inline">10 &amp; 01 = 0</span>) или мы можем сделать вот так:</p>
  <p class="code">a = a ^ 1;</p>
  <p>При первом запуске <span class="inline">0 ^ 1 = 1</span>, при втором <span class="inline">1 ^ 1 = 0</span>, таким образом, происходит переключение с 0 на 1.</p>
  <p>Итак - <span class="inline">OR</span> (<span class="inline">|</span>), <span class="inline">AND</span>(<span class="inline">&amp;</span>), <span class="inline">NOT</span>(<span class="inline">~</span>) и <span class="inline">EOR</span>(<span class="inline">^</span>) позволяют нам манипулировать битами с относительной легкостью, позволяя, на самом простом уровне, управлять несколькими битами одновременно. Очевидно, что при разработке игр мы можем использовать эти операции для других целей, например, маскировать <span class="notranslate">sprites</span>, выполнять целочисленные операции <span class="inline">MOD</span> (используя <span class="inline">AND</span>) или делать красивые циклические счетчики.</p>
  <p>Итак, мы можем выполнять простые побитовые операции, но давайте рассмотрим более сложные вещи, начиная с вопроса, как компьютер складывает? Давайте рассмотрим очень простой пример: <span class="inline">1+1</span>.</p>
  <p class="code">00000001<br />
    00000001<br />
    00000010</p>
  <p>Как и при обычном сложении, мы складываем числа вместе, а затем переполняем следующий столбец, но в отличие от обычного десятичного сложения, мы можем переходить только от 0 к 1, а не от 0 к 9. Таким образом, добавление <span class="inline">1+1</span> означает переполнение в <span class="inline">10</span>. Давайте рассмотрим более сложный пример.</p>
  <p class="code">01011011 = 91<br />
    00101101 = 45<br />
    10001000 = 136</p>
  <p>Очевидно, что здесь это сложнее увидеть, но переполнения пульсируют до тех пор, пока в столбце не останется ни одной единицы. Стоит отметить, что компьютеры могут складывать (или вычитать, умножать или делить) только 2 числа одновременно. Возьмем <span class="inline">19 + 19 + 19</span>. Будучи людьми, мы можем сложить все 9 вместе, перенести 2 и продолжить! Но компьютеры не могут этого сделать - они могут сделать вот что:<span class="inline"> (19 + 19) + 19</span>. Поэтому они будут выполнять каждое вычисление блоками по 2.</p>
  <p>Двоичные вычисления, которые представляют наибольший интерес для нас, программистов, - это умножение и деление. Компьютеры умножают только на 2, а чтобы сделать больше, они разбивают число на части, а затем складывают все результаты вместе. Давайте сначала рассмотрим несколько очень простых примеров. <span class="inline">4 * 2 = 8</span>. Чтобы умножить на 2 в двоичной системе, мы <em>сдвигаем </em>все биты влево на единицу. Вот так:</p>
  <p class="code">00000100 * 2 = 00001000 = 8</p>
  <p>В этом случае все биты сдвинулись влево на единицу, в результате чего число переместилось из 3-го бита в 4-й и изменило значение с 4 на 8. Как насчет большего числа?</p>
  <p class="code">101 = 01100101 * 2 = 11001010 = 202</p>
  <p>Опять же, все биты сдвигаются на единицу, и это умножается на 2. Итак, как насчет умножения на 4? Легко, мы сдвигаем все влево на 2, а не на 1. Так как насчет 16 или 128? Это потребует сдвига влево на 4 или 7 бит соответственно. Это невероятно полезно; это означает, что мы можем выполнять простые умножения, просто перемещая биты. Для этого мы используем оператор сдвига <strong>влево</strong> <span class="inline">&lt;&lt;</span>. Вот несколько примеров:</p>
  <p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br />
    00000001 &lt;&lt; 2 = 000000100 = 4<br />
    00000001 &lt;&lt; 3 = 000001000 = 8<br />
    00000001 &lt;&lt; 4 = 000010000 = 16<br />
    00000001 &lt;&lt; 5 = 000100000 = 32<br />
    00000001 &lt;&lt; 6 = 001000000 = 64<br />
    00000001 &lt;&lt; 7 = 010000000 = 128<br />
    00000001 &lt;&lt; 8 = 100000000 = 256</p>
  <p>Теперь, помимо того, что это очень полезно для быстрого/простого умножения, это также очень полезно для установки определенных битов, без необходимости выяснять значение бита. Допустим, мы хотим установить бит 27, что это за число? (67108864, кстати!), ну, мы можем использовать приведенный выше синтаксис, чтобы легко установить флаги, как это:</p>
  <p class="code">a = a | (1 &lt;&lt; 27)</p>
  <p>Хорошо... на самом деле это будет бит 26, как мы описывали до сих пор (поскольку биты начинаются с единицы), но на самом деле... биты начинаются с бита 0 и идут вверх, а не с бита 1. Поэтому, хотя в INTEGER 32 бита, биты начинаются с 0 до 31, а не с 1 до 32. На самом деле это довольно полезно, поскольку теперь мы можем задавать константы для битовых чисел.</p>
  <p>Допустим, бит 27 - активный флаг, а бит 0 - флаг взрыва. Как мы можем установить оба?</p>
  <p class="code">ACTIVE = 27;<br />
    BOOM = 0;<br />
    A = A | (1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM);</p>
  <p>Это может показаться большим количеством кода, но если эти числа являются константами, компилятор предварительно соберет эти операции в одно значение, так что в итоге мы получим вот такой код.</p>
  <p class="code">A = A | 13421772;</p>
  <p>Очистка этих битов (как мы видели выше) - это просто использование модификатора NOT, например, так:</p>
  <p class="code">A = A &amp; ~((1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM));</p>
  <p>Таким образом, это позволяет нам устанавливать и очищать любые биты, а также значительно сжимать структуры данных. Сжатие структур данных - это хорошо, потому что если вы используете меньше памяти, вы получаете меньше промахов кэша, и ваш код просто работает быстрее. Скажите, что быстрее - копировать 32 Мб данных или 4 Мб? Совершенно очевидно, что 4. Так что если вы можете упаковать все ваши флаги в один доступ к памяти, это хорошо!</p>
  <p>Теперь давайте вкратце рассмотрим, как выполняется деление, и почему это будет так полезно. Деление выполняется путем сдвига битов <em>вправо</em> с помощью оператора <strong>сдвига вправо</strong> <span class="inline">&gt;&gt;</span>. Возьмем простое число - 64 - и разделим его на 32:</p>
  <p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010</p>
  <p>Таким образом, вы сдвигаете единственный бит вниз на 5 (это количество сдвигов, необходимое для 32 - см. выше), что дает нам 2. Но что произойдет, если здесь есть другие биты? Давайте посмотрим:</p>
  <p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010</p>
  <p>Так что вот, пожалуйста.... Все точно так же. Биты, которые мы сдвигаем вниз, просто теряются. На самом деле это очень полезно, потому что при делении вниз, если нам нужен остаток, есть еще более простой способ его получить, к которому мы перейдем через некоторое время. Но сначала давайте рассмотрим практический пример. У меня есть позиция X и Y, и я хочу получить ячейку сетки, в которую она попадает, где сетка имеет размер 32x32. Этот метод позволяет хранить объекты, столкновения, флаги - всевозможные вещи, и обращаться к ним очень быстро. Итак, начнем:</p>
  <p class="code">var X_index = x &gt;&gt; 5;<br />
    var Y_index = y &gt;&gt; 5;<br />
    cell_data = mygrid[# X_index,Y_index];</p>
  <p>Итак, что если нам нужен остаток? Возможно, этот остаток используется как некий флаг порядка или что-то в этом роде. Какова бы ни была причина, получить остаток так же просто, как выполнить <span class="inline">AND</span>:</p>
  <p class="code">var remainder = x &amp; 31<br />
    var X_Index = x &gt;&gt; 5;</p>
  <p>Теперь вы, наверное, заметили, что мы использовали несколько строк кода (как это часто бывает), но это все равно всего лишь пара очень быстрых инструкций. Но почему именно 31? Так как бит 5 равен 32, то все биты ниже будут равны 31, а это максимальный остаток, поэтому мы используем <span class="inline">AND</span> (мы также можем использовать <span class="inline">(1 &lt;&lt; 5) - 1</span>, в результате чего получится <span class="inline">32 - 1 = 31</span>). Теперь, если бы я делал это без понимания двоичной системы счисления, это выглядело бы следующим образом:</p>
  <p class="code">var r = x mod 32;<br />
    var X_Index = floor(x / 32);</p>
  <p>Почему же это намного хуже? Чтобы разделить на 32, мы должны выполнить деление с плавающей запятой - что, очевидно, занимает время, но для того, чтобы сделать <span class="inline">mod 32</span>, нужно выполнить еще одно деление! Если бы мы делали это на ассемблере, мы бы получили ОБА значения за одно деление, но в языках высокого уровня такого не бывает (ну... не очень часто), и поэтому приходится выполнять всю работу дважды. Это увеличивается, особенно если вы выполняете узкий цикл с большим количеством вычислений, как в этом случае. Целочисленные деления с использованием сдвига битов, как показано выше, действительно помогают оптимизировать вашу игру.</p>
  <p>Поскольку эта концепция может быть довольно сложной для понимания и последующего применения в реальных ситуациях программирования, ниже вы найдете серию коротких примеров, которые могут быть применены к любой игре, созданной с помощью <span data-keyref="GameMaker Name">GameMaker</span>.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Выравнивание плитки</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Разработчики<span data-keyref="GameMaker Name">GameMaker</span> часто используют функцию <span class="inline">place_free()</span>, а затем, когда обнаружено столкновение, пытаются медленно вывести объект, либо обходя по кругу позиции <span class="inline">x</span> или <span class="inline">y</span>, продолжая выполнять эту функцию, либо используя функцию <span class="inline">move_outside_all()</span>.</p>
    <p class="dropspot">Итак, какой способ сделать это быстрее? Ну, если мы используем правильные тайлы power-of-2, то у нас есть очень простой метод, который также является молниеносным. Если мы движемся вправо и попали в блок столкновения, то, как мы знаем, все выравнивается по 32, поэтому нам нужно также выровнять <span class="notranslate">sprite</span> по 32-пиксельной границе - предпочтительно по левой - так, чтобы <span class="notranslate">sprite</span> был перемещен ВНЕ столкновения. Это очень просто, зная правила, которые мы использовали выше для получения остатка, и зная, как получить обратную величину битов, мы можем просто сделать следующее:</p>
    <p class="code">x = x &amp; ~31;</p>
    <p class="dropspot">Правильно, это ВСЕ, что требуется для выравнивания по границе 32 пикселей. Изменив 31, мы можем выровнять по любой границе - если только она является степенью 2. (Это эквивалентно делению на 32, затем умножению на 32, таким образом удаляя младшие биты).</p>
    <p class="dropspot">Если мы хотим выровнять вправо, то сделаем то же самое, но добавим 32, чтобы переместить его на следующую плитку. Все просто. Все это делает весь код столкновений монументально быстрее и позволяет тратить процессорное время там, где оно действительно нужно.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Ключи и двери</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Допустим, у вас есть уровень с несколькими дверями, и для каждой из них есть ключ. Как можно легко пометить ключ для определенной двери? Обычно вы просто присваиваете идентификатор ключу и двери. А что если вы хотите, чтобы ключ открывал 2 или 3 двери? Легко. Вы используете MASK. Дверь будет иметь один бит, назначенный следующим образом:<br />
       </p>
    <p class="code">door_id = 1; // 0001</p>
    <p class="dropspot">Остальные могут быть примерно такими:<br />
       </p>
    <p class="code">door_id=2; // 0010<br />
      door_id=4; // 0100<br />
      door_id=8; // 1000<br />
      etc...</p>
    <p class="dropspot">Если бы мы хотели, чтобы ключ открывал двери 1 и 3, то ключ имел бы значение MASK, равное 5 (что в двоичном формате равно 101). Если мы выполним <span class="inline">AND</span> и получится &quot;не ноль&quot;, то мы будем знать, что ключ может открыть дверь. Вы также можете иметь ключи, которые ничего не открывают, имея MASK равный 0. Смотрите код ниже для фактической проверки:</p>
    <p class="code">if ((key_id &amp; door_id) ! = 0)<br />
      {<br />
          opendoor();<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Петлевые счетчики</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Допустим, нам нужен простой счетчик анимации, идущий от 0 до 15 (поскольку у нас 16 кадров анимации). Обычно вы делаете инкремент, а затем выполняете проверку <span class="inline">if</span>, чтобы обернуть число, но для этого примера давайте воспользуемся оператором <span class="inline">AND(&amp;)</span>:</p>
    <p class="code">counter = (counter + 1) &amp; 15;</p>
    <p class="dropspot">Поскольку 16 - это степень 2, мы можем уменьшить это число на 1 и использовать его в качестве маски, которую затем можно использовать для обертывания значения счетчика. Если счетчик перейдет от 15 к 16, мы получим битовый шаблон <span class="inline">10000</span>, а если мы <span class="inline">AND</span> это 15 (битовый шаблон <span class="inline">01111</span>), мы получим <span class="inline">00000</span> (просто ноль). Это означает, что приведенный выше код полезен для обертывания значений в диапазоне степени 2.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Power Of 2 Check</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">Что, если вы хотите проверить, является ли что-то мощностью 2? Вот небольшой трюк... Это вернет <span class="inline">true</span>, если заданное значение является степенью 2:</p>
    <p class="code">function is_pow2(_val)<br />
      {<br />
          return _val &amp; (_val - 1)) == 0;<br />
      }</p>
    <p class="dropspot">Итак, если у нас есть число 51 (<span class="inline">110011</span>), что это дает? Ну, мы получаем вот это... <span class="inline">110011 &amp; 110010</span>, что, очевидно, оставляет нам <span class="inline">false</span>, поскольку после <span class="inline">AND</span> остается много битов. Если у нас было 64 (<span class="inline">1000000</span>), то получается вот это... <span class="inline">1000000 &amp; 0111111</span>, что <em>оставляет</em> нам 0, так что это <span class="inline">true</span>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Выравнивание индекса</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">Вот небольшой код для выравнивания по мощности 2 чисел. (1,2,4,8,16 и так далее). Это может быть очень полезно при распределении памяти или для того, чтобы убедиться, что вы записываете данные в соответствующие границы. В этом примере <span class="inline">_val1</span> нужно выровнять по байтам <span class="inline">_val2</span>, где <span class="inline">_val2</span> - число, равное 2. Эта маленькая функция округляет до следующей границы нужного числа.</p>
    <p class="code">function align_pow2(_val1, _val2)<br />
      {<br />
          return _val1 + (_val2 - 1)) &amp; ~(_val2 - 1);<br />
      }</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующий: <a href="Type_Tables.htm">Типовые таблицы</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Bitwise Operators
-->
  <!-- TAGS
bitwise_operators
-->
</body>
</html>