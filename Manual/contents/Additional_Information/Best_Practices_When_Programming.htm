<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Лучшие практики при программировании</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains some best practices when programming using GameMaker" />
  <meta name="rh-index-keywords" content="Best Practices When Programming" />
  <meta name="search-keywords" content="best practices" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Лучшие практики при программировании</h1>
  <p>На этой странице мы расскажем о некоторых &quot;лучших практиках&quot; программирования игры, а также немного объясним внутреннюю работу <span data-keyref="GameMaker Name">GameMaker</span>. Однако прежде чем продолжить, стоит обратить внимание на два очень важных момента:</p>
  <ul class="colour">
    <li>Это <em>руководство</em>, а не универсальный и окончательный метод написания игры! Упомянутые здесь вещи относятся скорее к организационной и микро-оптимизации и должны быть включены в ваши привычки программирования, когда вы чувствуете себя комфортно с <span class="notranslate">GML</span> и считаете, что они уместны.</li>
    <li>Если ваша игра работает нормально и вас все устраивает, то <em>не спешите все менять только для того, чтобы выжать несколько дополнительных FPS</em>. Вы должны найти баланс между читабельным, гибким и модульным кодом и временем и энергией, необходимыми для внесения изменений, а также общим выигрышем в итоге. В общем, если ничего не сломалось, не чините, а то, что вы узнали здесь, сохраните для следующего проекта.</li>
  </ul>
  <p>С учетом сказанного, давайте продолжим и рассмотрим некоторые общие советы по написанию хорошего кода <span class="notranslate">GML</span>, которые вы можете применять в любое время...</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Стиль программирования</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Когда дело доходит до написания кода, у каждого есть свой <em>стиль</em>. Стиль, в котором вы программируете, - это то, как вы расставляете скобки, как делаете отступы в строках, как объявляете и называете переменные и т.д., и это очень важно для того, чтобы ваш код был понятен и читабелен для других людей (и для вашего будущего "я", когда вам придется вернуться к этому проекту после некоторого времени работы над чем-то другим).</p>
    <p class="dropspot">Существует много, много <a href="http://en.wikipedia.org/wiki/Programming_style">стилей программирования</a>, и некоторые могут утверждать, что именно их стиль является лучшим для использования, но правда в том, что практически любой стиль подходит, если вы <strong>последовательны </strong>в его использовании и <em>ясно </em>и <em>очевидно </em>, что все является и делает.</p>
    <p class="dropspot"><img>На рисунке выше приведен пример объявления функции в скрипте, иллюстрирующий вышеизложенные моменты. Видно, что в нем используются комментарии в стиле JSDoc, чтобы четко объяснить, что все это делает, а стиль кодирования соответствует, с отступами в 4 пробела, подчеркиваниями, используемыми для локальных переменных, протоколируемым выводом и т.д..</p>
    <p class="dropspot">Также обратите внимание, что хотя редактор сценариев позволяет сворачивать код в каждой из открытых/закрытых скобок, вы можете использовать теги <span class="inline">#region</span> и <span class="inline">#endregion</span> для разделения частей вашего кода и значительного улучшения читабельности, особенно при работе с большими сценариями, содержащими множество функций. Регионы также можно комментировать - см. раздел "Редактирование" на этой странице руководства):</p>
    <p class="dropspot"><img>При написании кода вы должны знать, что при компиляции готовой игры <span data-keyref="GameMaker Name">GameMaker</span> удаляет комментарии, убирает ненужные переносы строк и пробелы, подставляет значения констант, макросов и переменных и в целом сжимает ваш код. Это означает, что вы можете добавлять столько пробелов в коде, сколько необходимо, и вам не нужно беспокоиться о том, чтобы ваши комментарии были короткими или использовались редко.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Используйте локальные переменные</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Продолжая тему стиля программирования, можно сказать, что многие начинающие программисты стремятся впихнуть как можно больше в одну строку кода. Например:</p>
    <p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p>
    <p class="dropspot">Хотя он и не совсем нечитабелен, но неэффективен (например, функция <span class="inline">point_direction()</span> вызывается дважды), а также грязен и неудобен на вид. Гораздо лучше было бы выразить это как:</p>
    <p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br />
      var local_x = x + lengthdir_x(100, p_dir);<br />
      var local_y = y + lengthdir_y(100, p_dir);<br />
      draw_sprite(sprite_index, image_index, local_x, local_y);</p>
    <p class="dropspot">Память и ресурсы, необходимые для создания этих локальных переменных, ничтожно малы, и их значительно перевешивает мгновенная польза, которую вы (или любой другой человек, читающий код позже) получите от его ясности. Та же идея должна быть применена и к функциям, где вы должны присваивать разумные имена входным переменным, использовать четкое форматирование и локальные переменные, где это необходимо, чтобы сделать код как можно более читабельным.</p>
    <p class="dropspot">Локальные переменные быстро обрабатываются в игре, поэтому используйте их по максимуму, а если выражение появляется в блоке кода или скрипте два или более раз, подумайте о создании локальной переменной для него. При использовании целей <a class="glossterm" data-glossterm="YoYo Compiler (YYC)" href="#">YoYo Compiler (YYC)</a>, если вы ссылаетесь на <span class="inline">global</span> или переменные экземпляра несколько раз в функции или блоке кода, особенно полезно присвоить их локальной переменной в начале кода, а затем ссылаться на эту локальную переменную, так как это обеспечит гораздо более высокую производительность.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Массивы</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">Массивы</a> быстры в использовании и требуют меньше памяти, чем структуры данных, но их можно еще больше оптимизировать. При создании массива память для него выделяется в зависимости от его размера, поэтому сначала следует попытаться инициализировать массив до максимального размера, даже если вы не планируете заполнять его в дальнейшем. Например, если вы знаете, что массив должен содержать максимум 100 значений, вы сразу инициализируете его до 100 слотов, используя функцию <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> функция:</p>
    <p class="code">array = array_create(100, 0);</p>
    <p class="dropspot">Это выделяет память для него одним &quot;куском&quot;, при этом все значения массива устанавливаются в значение 0 по умолчанию, что помогает поддерживать быстрое выполнение, поскольку в противном случае каждый раз, когда вы добавляете новое значение в массив, вся память должна быть выделена заново.</p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Для цели HTML5 присвоение массивов подобным образом не применяется, и ваши массивы должны инициализироваться с 0 для этой цели! Вы можете легко справиться с этим, проверив переменную os_browser, например:</p>
    <p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br />
        {<br />
            array_create(100, 0);<br />
        }<br />
        else<br />
        {<br />
            for (var i = 0; i &lt; 100; ++i;)<br />
            {<br />
                array[i] = 0;<br />
            }<br />
        }</span></p>
    <p class="dropspot">Вы также можете освободить память, связанную с массивом, установив используемую переменную равной 0. Таким образом, чтобы очистить массив из приведенного выше примера кода, достаточно использовать:</p>
    <p class="code">array = 0;</p>
    <p class="dropspot">Также обратите внимание, что массивы передаются <strong>по ссылке</strong>, но при изменении будут копироваться целиком (такое поведение называется <strong>copy on write</strong>). Таким образом, если вы передаете массив функции, вы передаете <em>ссылку </em>на исходный массив, и любые значения, считанные из него, будут получены из исходного источника. Это хорошо и быстро, но если вам нужно изменить какие-либо значения массива, сам массив дублируется в момент записи, и все сделанные изменения <strong>должны быть возвращены из функции, иначе они будут потеряны</strong>. Это намного медленнее и потребляет больше памяти, поэтому будьте осторожны при использовании массивов в функциях.</p>
    <p class="dropspot">Однако вы можете избежать такого поведения при копировании при записи, используя специальный <a href="../GameMaker_Language/GML_Overview/Accessors.htm">аксессор</a> массива <span class="inline">@</span>, так как он дает прямой доступ к базовому массиву. Например:</p>
    <p class="code">// Call a function, passing our array<br />
      my_function(my_array);</p>
    <p class="code">// The function looks like this:<br />
      <br />
      function my_function(_a)<br />
      {<br />
          // The array will be copied and the copy modified,<br />
          // requiring you to use &quot;return _a&quot;, later<br />
          _a[0] = 100;<br />
      <br />
          // This will modify the ORIGINAL array directly and<br />
          // does not require it to be returned<br />
          _a[@ 0] = 100;<br />
      }
    </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Структуры данных</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">В <span data-keyref="GameMaker Name">GameMaker</span> <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">структуры данных</a> были оптимизированы таким образом, чтобы быть намного быстрее, чем в предыдущих версиях <span class="notranslate">GameMaker</span>. Их по-прежнему нужно очищать (уничтожать), когда они не используются, чтобы освободить память, и они все еще могут быть медленнее, чем, скажем, массивы, но простота использования и дополнительные функции для работы с данными, которые они содержат, часто перевешивают минимальную разницу в скорости, поэтому не бойтесь использовать их в своих играх.</p>
    <p class="dropspot">Следует отметить, что из всех структур данных, DS Maps, в частности, отличаются высокой скоростью чтения и записи, что делает их отличным вариантом для всех типов задач.</p>
    <p class="dropspot">Ранее мы упоминали <a href="../GameMaker_Language/GML_Overview/Accessors.htm">аксессоры</a> для массивов, но они также доступны для структур данных, что может помочь очистить ваш код и сделать его намного легче для чтения.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Столкновения</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">В <span data-keyref="GameMaker Name">GameMaker</span> существует <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">множество способов борьбы с коллизиями</a>, и большинство из них сопровождается небольшими дополнительными нагрузками на процессор. Функции <span class="inline">collision_</span> и <span class="inline">point_</span>, <span class="inline">place_</span> и <span class="inline">instance_</span> опираются на проверку <a class="glossterm" data-glossterm="ограничительная рамка" href="#">ограничивающих рамок</a> для всех экземпляров данного типа в комнате, и хотя в движок встроена некоторая оптимизация для ограничения этих проверок, столкновения никогда не являются наиболее эффективным способом борьбы с ними. Если вы начнете использовать точные коллизии, производительность также заметно ухудшится, поскольку вы не только будете выполнять проверку пограничной области, но и попиксельную проверку, что очень медленно.</p>
    <ul class="dropspotlist">
    </ul>
    <p class="dropspot">Это не означает, что вы не должны использовать эти функции, так как они могут быть очень удобными. Однако вы должны знать, какие из них использовать и когда, поскольку все они работают немного по-разному и имеют разную скорость. Примерное правило гласит, что функции <span class="inline">place_</span> работают быстрее, чем функции <span class="inline">instance_</span>, которые быстрее, чем функции <span class="inline">collision_</span> и <span class="inline">point_</span>, поэтому прочитайте страницы руководства по каждому из этих типов функций и убедитесь, что выбрали наиболее подходящую для каждой ситуации.</p>
    <p class="dropspot">В качестве альтернативы рассмотрите возможность создания<strong> системы столкновений на основе плиток</strong>, которые можно создать с помощью <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">функций tilemap</a> или даже пользовательского двумерного массива или сетки DS. Они будут очень быстрыми и помогут увеличить скорость вашей игры. Однако если вы используете нерегулярную местность или стены и объекты, которые не выравниваются по сетке, они могут не подойти. Вы можете найти очень простой учебник по столкновениям тайлмапов по следующей видеоссылке</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0">Коллизии плиток в <span data-keyref="GameMaker Name">GameMaker</span></a></li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">Замена текстур и партии вершин</a></p>
  <div class="droptext" data-targetname="drop-down5">
    <p class="dropspot">Если вы включите <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>наложение отладки</strong></a>вы увидите, что во время тестирования в верхней части экрана отображаются две цифры в скобках. Первая - это количество выполняемых <strong>обменов текстур </strong>, а вторая - количество <strong>вершинных батчей</strong>. На эти цифры влияет множество факторов, и вам никогда не удастся свести их к (0) (0), поскольку движок требует выполнения одного или двух операций на каждом шаге, но вы должны стремиться свести эти значения как можно ниже.</p>
    <p class="dropspot"><img>Для замены текстур лучшим и наиболее эффективным способом является оптимизация хранения <span class="notranslate">sprites</span> и фона на странице текстур. Это делается в <a href="../The_Asset_Editors/Sprites.htm">свойствах спрайта</a>, и вы можете создавать страницы текстур в <a href="../Settings/Texture_Groups.htm">редакторе групп текстур</a>. Если у вас есть несколько изображений, которые используются только в главном меню (например), поместите их вместе на отдельную <a href="../Settings/Texture_Information/Texture_Pages.htm">страницу текстур</a>. То же самое, если у вас есть изображения, специфичные для уровня, или для игрока, врагов и т.д. В общем, вы хотите сгруппировать их по использованию, чтобы максимально сократить количество подмен. Кроме того, для оптимизации <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a> вы можете использовать различные функции <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">prefetch и flush</a> для загрузки и удаления текстур из памяти по мере необходимости.</p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Как уже упоминалось в начале этой страницы, если ваша игра работает нормально и с приличным FPS, то не стоит слишком беспокоиться о замене текстур... особенно при создании проектов на настольных компьютерах. Эти оптимизации лучше всего использовать в больших играх или на мобильных устройствах низкого класса, а при неправильном использовании они могут негативно повлиять на производительность.</p>
    <p class="dropspot">Информация о вершинах отправляется &quot;партиями&quot; на GPU для отрисовки, и в целом, чем больше партия, тем лучше. Поэтому при отрисовке следует избегать &quot;разрыва&quot; пакета, так как это увеличит количество пакетов вершин, отправляемых на GPU. Существует ряд вещей, которые нарушают пакет, основными из них являются <strong>режимы наложения</strong>, изменение <strong>шейдера</strong>, изменение формы для шейдера перед отрисовкой, а также отрисовка с использованием встроенных фигур и примитивов.</p>
    <p class="dropspot">Так, если у вас есть несколько экземпляров пуль, которые рисуются с использованием режима наложения <span class="inline">bm_add</span>, например, вы будете создавать новую партию вершин для каждой из них, что определенно плохо! Вместо этого в вашей игре есть объект контроллера, который рисует все пули, например, так:</p>
    <p class="code">gpu_set_blendmode(bm_add);<br />
      <br />
      with (obj_BULLET)<br />
      {<br />
          draw_self();<br />
      }<br />
      <br />
      gpu_set_blendmode(bm_normal);
    </p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Это относится не только к использованию <span class="inline" style="font-size: 14px">bm_add</span> - любое изменение смешивания нарушит пакет и приведет к снижению производительности.</p>
    <p class="dropspot">Таким образом, все пули будут нарисованы в одной партии. Разумное использование функций <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a>, <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a>, и <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a> может значительно повысить производительность и может быть включено/выключено по мере необходимости в коде вашего проекта, хотя они могут не подходить для всех типов графики или проектов.</p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Если вам не нужно, чтобы экземпляр рисовал сам себя при использовании контроллера таким образом, вы можете просто добавить комментарий в событие Draw Event, чтобы подавить рисование по умолчанию, или сделать экземпляр невидимым (хотя это предотвратит выполнение кода для экземпляра во всех событиях draw).</p>
    <p class="dropspot">Другой способ уменьшить эти числа - отключить опцию <strong>Separate Texture Page</strong> для <span class="notranslate">sprites</span>, если это не является абсолютно необходимым. Каждое изображение, сохраненное таким образом, отправляется на свою собственную страницу текстур и по-разному сортируется, поэтому лучше иметь эти изображения на обычной странице текстур. Затем вы можете получить координаты UVS с помощью функции <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> и сохранить их в переменных для последующего использования. Это может быть небольшое количество дополнительного кода, но эффект, который вы получите, того стоит. Обратите внимание, что этот метод не позволяет повторять текстуры!</p>
    <p class="dropspot">Как и в случае со всеми этими советами, если их изменение усложняет вашу жизнь, а игра работает нормально, не стоит слишком беспокоиться об этом...</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">Частицы</a></p>
  <div class="droptext" data-targetname="drop-down6">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">Частицы</a> - это очень быстрый и эффективный способ создания динамических эффектов в вашей игре, и в целом они обеспечивают хорошую производительность. Однако стоит отметить, что использование аддитивного смешивания, альфа-смешивания и смешивания цвета для частиц может снизить эту производительность, особенно на мобильных объектах, поэтому если вам это не нужно, не используйте это! Аддитивное смешивание, в частности, может значительно увеличить партии вершин и должно использоваться с осторожностью.</p>
    <p class="dropspot">Обратите внимание, что для HTML5, не поддерживающего WebGL, наличие разноцветных исчезающих частиц потребует кэширования большого количества изображений и будет работать очень медленно. Однако, поскольку частица <span class="notranslate">sprites</span> может быть анимированной, вы можете создать анимированный <span class="notranslate">sprite</span>, который имеет подизображения, меняющие цвет, и затем использовать его для частицы. Это все равно будет выглядеть как постепенное изменение цвета, но не потребует постоянного создания кэш-изображений.</p>
    <p class="dropspot">Вы можете узнать больше о частицах на странице <a href="Guide_To_Using_Particles.htm">Руководство по использованию частиц</a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">Поверхности</a></p>
  <div class="droptext" data-targetname="drop-down7">
    <p class="dropspot">Наконец, мы вкратце коснемся использования <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">поверхностей</a>, поскольку в <span data-keyref="GameMaker Name">GameMaker</span> есть довольно значительная оптимизация при их использовании в играх: возможность включать и выключать <strong>буфер глубины</strong>.</p>
    <p class="dropspot">Когда вы просто используете поверхности как обычно, <span data-keyref="GameMaker Name">GameMaker</span> фактически создает поверхность и сопутствующий буфер глубины для обеспечения правильной сортировки глубины при рисовании чего-либо в 3D. Однако в большинстве 2D-игр этот дополнительный буфер глубины просто не нужен и занимает дополнительное пространство памяти и время обработки, которое можно было бы использовать для других целей. Вот где функция <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a> вступает в игру...</p>
    <p class="dropspot">Эту функцию можно вызвать до создания поверхности, чтобы отключить генерацию буфера глубины, и все поверхности, созданные после этого, не будут иметь созданного для них буфера глубины. Вы можете включать/выключать эту функцию по мере необходимости, и даже можете вызвать ее один раз в начале игры, чтобы отключить буферы глубины для всех последующих вызовов поверхностей (и в большинстве 2D-игр это нормально). Это не даст значительного прироста производительности, но это, безусловно, то, о чем следует помнить, если ваша игра в значительной степени зависит от поверхностей, и может остановить нехватку памяти на устройствах с более низкими характеристиками.</p>
  </div>
  <p> </p>
  <p>Помимо основных вещей, упомянутых выше, есть и другие, более общие вещи, которые могут помочь в производительности и которые также считаются &quot;хорошей практикой&quot;:</p>
  <ul class="colour">
    <li>не бойтесь использовать тригонометрические функции, поскольку (вопреки распространенному мнению) они довольно быстрые, особенно по сравнению с частицами, столкновениями, струнами и т.д....</li>
    <li>не помещайте в события Draw код, не предназначенный для рисования предметов</li>
    <li>использовать сигнал тревоги для вызова любого кода, который не нужно вызывать каждый шаг (вместо того, чтобы просто добавить это в событие Step)</li>
  </ul>
  <p>Но, как мы уже упоминали в начале страницы, все эти оптимизации необязательны, и если ваша игра прекрасно работает с 60 вершинными партиями, 80 сменами текстур, аддитивным смешиванием и т.д., то не стоит слишком беспокоиться об этом! Просто помните об этих вещах, когда будете программировать свою следующую игру...</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующий: <a href="The_File_System.htm">Файловая система</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->
</body>
</html>