<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Руководство по использованию частиц</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
    <script src="../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page that explains how to set up and use particles" />
    <meta name="rh-index-keywords" content="Guide To Using Particles" />
    <meta name="search-keywords" content="particles,particle guide,particle setup" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Руководство по использованию частиц</h1>
    <p>Это руководство предназначено для тех, кто хочет понять, как использовать и создавать <strong>частицы</strong>. На этой странице будут рассмотрены <a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">функции языка GameMaker Language</a> и <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Particles/Particle_Actions.htm">визуальные действия GML</a> для частиц. Если вы никогда раньше не использовали частицы, мы надеемся, что это руководство поможет вам начать, поскольку они очень полезны и довольно забавны в создании.</p>
    <p>Прежде чем продолжить, мы, вероятно, должны объяснить, что такое частица... По сути, частица - это графический ресурс, имеющий определенные свойства, которые определяются <strong>системой частиц</strong>. Этими свойствами нельзя управлять непосредственно для <em>отдельных </em>частиц, но они изменяются коллективно с помощью кода или действий, которые используются для определения системы, к которой они принадлежат. Они очень полезны для создания красивых и ярких эффектов - или тонких и незаметных - в игре без нагрузки на процессор, которую несет использование экземпляров.</p>
    <p>Мы уже упоминали о системах частиц, поэтому давайте объясним, что это такое, прежде чем продолжить. Думайте о системе частиц как о контейнере, который вы будете использовать для хранения частиц, готовых к использованию. Вы можете использовать код или действия для определения визуального аспекта частиц, а затем они помещаются в &quot;контейнер&quot; (систему частиц), чтобы вы могли достать его и использовать в любое время и в любом месте, где он вам понадобится.</p>
    <p>Прежде чем настраивать систему и создавать частицы, важно знать несколько вещей... Во-первых, большая часть кода системы частиц вызывается <strong>только один раз в игре</strong>, обычно в каком-нибудь объекте контроллера в первой комнате или уровне - это не всегда так, но для простоты мы будем использовать этот сценарий в следующем кратком руководстве, поскольку это самый распространенный способ использования частиц. Это делается потому, что система частиц, однажды созданная, остается в памяти и готова к использованию в любое время, поэтому если вы создаете ее более одного раза, это может быстро увеличить использование памяти и вызвать серьезные задержки, и даже может привести к краху игры. Для простоты в этом руководстве вы создадите <strong>глобальную </strong>систему частиц, которая может быть использована любым экземпляром в игре в любое время.</p>
    <p> </p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Создание системы частиц</a></p>
    <div class="droptext" data-targetname="drop-down">
      <p class="dropspot">Для начала необходимо определить систему частиц и дать ей имя, чтобы ее можно было использовать. Поскольку это будет глобальная система, которую может использовать любой объект, вы должны сделать это в объекте контроллера или в функции инициализации, запускаемой в начале игры. Сайт <span class="notranslate">GML</span> будет выглядеть следующим образом:</p>
      <p class="code">global.P_System = part_system_create_layer(&quot;Instance_Layer&quot;, false);</p>
      <p class="dropspot">И используя <span class="notranslate">GML</span> Visual:</p>
      <p class="dropspot"><img>Обратите внимание, что указанное имя слоя должно быть действительным слоем в помещении, где будет использоваться система, иначе частицы не будут видны. Также обратите внимание, что мы установили флаг &quot;persistent&quot; (как в коде, так и в <span class="notranslate">GML</span> Visual) на false. Постоянная система частиц - это система, которая будет &quot;сохраняться&quot; в разных комнатах без необходимости уничтожать и создавать ее заново для каждой комнаты. Однако, чтобы упростить задачу, в данном руководстве мы не будем использовать постоянство.</p>
      <p class="dropspot">Итак, система создана, но как насчет частиц? Мы должны определить и их, иначе система бесполезна и ничего не делает.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Определение типа частицы</a></p>
    <div class="droptext" data-targetname="drop-down1">
      <p class="dropspot">Чтобы использовать частицу в системе, необходимо сначала определить ее общие свойства. Они похожи на свойства объекта, но применяются только в <em>общем случае </em>к отдельным частицам. Это означает, что если вы зададите частицам минимальную скорость движения 1 и максимальную скорость движения 2, то любая частица, созданная системой, будет иметь случайную скорость между 1 и 2 пикселями за шаг, и в целом их средняя скорость будет равна 1,5. Вы должны назвать и добавить первую частицу в систему, используя следующий <span class="notranslate">GML</span> в том же объекте, который вы использовали для создания системы:</p>
      <p class="code">global.Particle1 = part_type_create();</p>
      <p class="dropspot">И для тех из вас, кто использует <span class="notranslate">GML</span> Visual:</p>
      <p class="dropspot"><img>Обратите внимание, что при использовании <span class="notranslate">GML</span> Visual мы также отмечаем опцию <strong>смешивания </strong>. Это включает <strong>аддитивное смешивание</strong> для частиц, о котором мы поговорим чуть ниже.</p>
      <p class="dropspot">Теперь у вас есть система и частица, которую нужно в нее поместить, но вы еще не готовы к созданию выдающихся эффектов! Вам еще предстоит определить свойства частицы, то есть то, как она выглядит - ее скорость, ее вращение, ее альфа и т.д.... Существует множество деталей, которые можно использовать для определения эффекта частицы, поэтому ниже приведен обзор наиболее важных параметров, а также фрагмент кода и <span class="notranslate">GML</span> Visual, который использует их все:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><strong>форма</strong>: Форма частицы - это встроенная <span class="notranslate">sprite</span>, которую она будет использовать, по умолчанию это постоянная <span class="inline">pt_shape_pixel</span>. Существует также функция для добавления пользовательской частицы, если это необходимо - <a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particle_Types/part_type_sprite.htm"><span class="inline">part_type_sprite()</span></a> - или действие <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Particles/Set_Particle_Sprite.htm">Set Particle Sprite</a>.</li>
        <li class="dropspot"><strong>размер</strong>: Устанавливает параметры размера для типа частиц. Вы указываете минимальный начальный размер, максимальный начальный размер и увеличение размера на каждом шаге (для уменьшения размера используйте отрицательное число). Это скалярное значение, которое одинаково изменяет масштаб x/y базового изображения.</li>
        <li class="dropspot"><strong>color</strong>: Задает цвет для частицы, если используется один цвет. Если используются два или три цвета, это будет цветовая смесь, смешивающаяся от одного к другому в течение всего времени существования частицы.</li>
        <li class="dropspot"><strong>alpha</strong>: Устанавливает значение альфа для частицы между значениями 0 и 1. Если передано одно значение, то это будет альфа частицы, если передано два или три значения, то альфа будет смешиваться между ними в течение жизни частицы.</li>
        <li class="dropspot"><strong>speed</strong>: задает свойства скорости для типа частицы. Вы указываете минимальную и максимальную скорость, а при создании частицы выбирается случайное значение между заданными границами. Вы можете указать увеличение скорости на каждом шаге и даже использовать отрицательные числа, чтобы замедлить частицу (скорость никогда не станет меньше 0).</li>
        <li class="dropspot"><strong>направление</strong>: Устанавливает свойства направления для типа частицы. Вы снова задаете диапазон направлений (в градусах против часовой стрелки - 0 означает движение вправо, 90 - движение вверх и т.д.). Например, чтобы частица двигалась в случайном направлении, вы можете выбрать минимальное значение 0 и максимальное 360. Вы также можете указать увеличение направления для каждого шага (может быть и отрицательным).</li>
        <li class="dropspot"><strong>ориентация</strong>: Устанавливает свойства угла ориентации для типа частиц. Вы указываете минимальный угол, максимальный угол и увеличение на каждом шаге. Вы также можете указать, должен ли заданный угол быть относительным к текущему направлению движения или абсолютным, например: установив все значения на 0, а относительный на true, ориентация частицы будет точно следовать траектории частицы.</li>
        <li class="dropspot"><strong>смешивание</strong>: Устанавливает, использовать ли <strong>аддитивное </strong>смешивание или <strong>обычное </strong>смешивание для типа частиц. Этот параметр задается в функции при использовании <span class="notranslate">GML</span> и как часть инициализации частиц при использовании <span class="notranslate">GML</span> Visual. Аддитивное смешивание означает, что частицы будут использовать режим наложения <span class="inline">bm_add</span>, придавая им &quot;светящийся&quot; вид в местах наложения, а также смешивая их со всем, что нарисовано под ними (<span class="notranslate">sprites</span>, фоны, плитки и т.д...) - очень полезно для огненных и магических эффектов (например), но лучше не использовать для чего-то вроде дыма. Поэкспериментируйте, чтобы увидеть разницу! Обратите внимание, что включение этой функции нарушит пакетную обработку текстур при создании частиц, поэтому для их отрисовки потребуется больше пакетов за шаг - это следует учитывать, так как это может повлиять на производительность, особенно на мобильных устройствах.</li>
        <li class="dropspot"><strong>жизнь</strong>: Устанавливает границы времени жизни в шагах (игровых кадрах) для данного типа частиц. Как и в предыдущих настройках, здесь есть минимальное и максимальное значение, и частицы будут существовать случайное количество шагов в пределах этих значений. Так, при времени жизни 30 мин и 30 макс частица будет существовать ровно 30 шагов, а при времени жизни 20 мин и 60 макс каждая частица будет существовать случайное количество шагов от 20 до 60.</li>
      </ul>
      <p class="dropspot">Теперь, прежде чем мы представим вам код для определения частицы, давайте немного поговорим о &quot;<strong>wiggle</strong>&quot;... Хотите верьте, хотите нет, но &quot;wiggle&quot; является свойством частицы и может быть установлено для многих из вышеперечисленных параметров по отдельности. Когда вы видите &quot;wiggle&quot; в качестве аргумента для функции или действия частицы, это означает, что если вы поставите число от 1 до 20, частица будет &quot;вихлять&quot; или колебаться между минимальным и максимальным значениями для этого свойства, причем 1 - это медленное вихляние, а 20 - очень быстрое. Таким образом, частица со скоростью минимум 2 и максимум 5 с "вихлянием" 20 будет очень быстро колебаться между минимальной и максимальной скоростями в течение времени жизни каждой созданной частицы.</p>
      <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Существуют и другие незначительные свойства частиц, которые мы здесь не рассматриваем, чтобы максимально упростить процесс. Полная информация о свойствах частиц приведена на соответствующих страницах.</p>
      <p class="dropspot">Давайте теперь посмотрим на код, определяющий частицу:</p>
      <p class="code">// This defines the particle&#39;s shape
        <br/>
        part_type_shape(global.Particle1,pt_shape_pixel);
        <br/>
        <br/>
        // This is for the size
        <br/>
        part_type_size(global.Particle1,1,1,0,2);
        <br/>
        <br/>
        // This sets its colour. There are three different codes for this
        <br/>
        part_type_color1(global.Particle1,c_white);
        <br/>
        <br/>
        // This is its alpha. There are three different codes for this
        <br/>
        part_type_alpha1(global.Particle1,1);
        <br/>
        <br/>
        // The particles speed
        <br/>
        part_type_speed(global.Particle1,0.50,2,-0.10,0);
        <br/>
        <br/>
        // The direction
        <br/>
        part_type_direction(global.Particle1,0,359,0,20);
        <br/>
        <br/>
        // This changes the rotation of the particle
        <br/>
        part_type_orientation(global.Particle1,0,0,0,0,true);
        <br/>
        <br/>
        // This is the blend mode, either additive or normal
        <br/>
        part_type_blend(global.Particle1,1);
        <br/>
        <br/>
        // This is its lifespan in steps
        <br/>
        part_type_life(global.Particle1,5,30); </p>
      <p class="dropspot">Чтобы создать такое же определение частицы в <span class="notranslate">GML</span> Visual, нам понадобятся следующие действия:</p>
      <p class="dropspot"><img>Вот и все! Теперь мы определили наши частицы, и они готовы к использованию.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Создание частиц непосредственно в игре</a></p>
    <div class="droptext" data-targetname="drop-down2">
      <p class="dropspot">Существует несколько способов создания частиц, и каждый из них имеет свои плюсы и минусы. Вы можете использовать <strong>эмиттеры</strong> для <strong>разрыва </strong>или <strong>потока </strong>частиц, а можете создавать частицы <strong>непосредственно </strong>в точке. Выбор способа зависит от того, чего вы пытаетесь достичь и какой эффект хотите создать, но мы начнем с самого простого из них - создания частиц напрямую. В <span class="notranslate">GML</span> мы используем следующую функцию:</p>
      <p class="code">part_particles_create(global.P_System, x, y, global.Particle1, 10);</p>
      <p class="dropspot">и в <span class="notranslate">GML</span> Визуально это будет:</p>
      <p class="dropspot"><img>Этот единственный код/действие выше создаст 10 частиц в заданных координатах x/y типа &quot;Particle1&quot; из нашей глобальной системы. Просто! Самое замечательное в этой строке кода/действия то, что ее можно использовать в любом месте без лишних усилий. Например, если вы поместите ее в <strong>глобальное</strong> событие <strong>нажатия левой кнопки</strong> мыши в объекте и измените значения x/y для позиции mouse_x/y, она будет создавать частицы в позиции мыши каждый раз, когда вы нажимаете кнопку. Или, если у вас есть ракета, вы можете поместить это в событие шага, и частицы дыма будут появляться каждый шаг (хотя 1 или 2 будет лучше, чем 10!). Можно даже заставить его создавать частицы по области, например, случайным образом изменяя координаты x/y:</p>
      <p class="code">repeat(50)
        <br/>
        {
        <br/>
        var xx = x + 20 - random(40);
        <br/>
        var yy = y + 20 - random(40);
        <br/>
        part_particles_create(global.P_System, xx, yy, global.Particle1, 1);
        <br/>
        }</p>
      <p class="dropspot"><img>Приведенный выше код создаст 50 частиц в случайном положении в пределах квадратной области размером 40px.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Создание частиц с помощью излучателей</a></p>
    <div class="droptext" data-targetname="drop-down3">
      <p class="dropspot">Поскольку мы объяснили простой способ создания частиц, давайте теперь пойдем более сложным путем, который заключается в использовании <strong>эмиттеров</strong>. Эмиттеры - это еще одна часть системы частиц, которая должна быть определена перед использованием, поэтому мы создадим глобальный эмиттер так же, как мы это делали для системы и частиц. Нам также нужно решить, будет ли эмиттер статичным (недвижущимся) или нет, будем ли мы <strong>выпускать </strong>или <strong>распылять </strong>частицы, а также решить, на какой площади и какое распределение будет использовать эмиттер.</p>
      <p class="dropspot">Что все это значит? <strong>Статический </strong>эмиттер - это тот, который вы можете задать один раз и забыть о нем, поскольку он не будет никуда двигаться в течение всей игры, т.е. представьте себе костер из поленьев - он не движется, он просто излучает пламя и поэтому статичен, но для огненного шара потребуется <strong>динамический</strong> эмиттер, который будет двигаться по экрану. Что касается всплеска или потока, то всплеск - это одноразовый взрыв частиц, в то время как поток - это постоянный поток частиц на каждом шагу. Что касается области и распределения, то с помощью эмиттеров можно определить область для излучения частиц (это может быть прямоугольник, эллипс, ромб или линия), а также кривую распределения (гауссову, обратную гауссову или линейную).</p>
      <p class="dropspot">Следующие изображения иллюстрируют различные типы формы области, доступные для излучателей:</p>
      <p class="dropspot"> </p>
      <center><img alt="Create Particle System" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_CreateSystem.png"/> <img alt="Create Particle Type" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Create_Type.png"/></center>
      <center><img alt="Define Particle Type" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Define_Particle.png"/> <img alt="Create Particles At A Position" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Burst.png"/></center>
      <p class="dropspot">
        <br />
        А кривые распределения (линейная, гауссова и обратная гауссова) показаны здесь:</p>
      <p><img alt="Create Particles Over A Random Area" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Create_Particles.png"/></p>
      <p class="dropspot">Ниже приведен пример кода/действий, необходимых для определения двух эмиттеров, которые обычно идут в <strong>событии Create</strong> объекта контроллера, сразу после определения системы частиц. Один из них будет статичным и будет распылять частицы по площади всей комнаты, а другой будет динамичным и будет следовать за мышью и вырываться каждые 30 шагов из небольшого эллипса:</p>
      <p> </p>
      <p class="code">global.Particle1_Emitter1 = part_emitter_create(global.P_System);
        <br/>
        global.Particle1_Emitter2 = part_emitter_create(global.P_System);
        <br/>
        <br/>
        // Set up the area that will emit particles
        <br/>
        part_emitter_region(global.P_System, global.Particle1_Emitter1, 0, room_width, 0, room_height, ps_shape_rectangle, ps_distr_linear);
        <br/>
        part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x-10, mouse_x+10, mouse_y-10, mouse_y+10, ps_shape_ellipse, ps_distr_gaussian);
        <br/>
        <br/>
        // Set the first to stream 10 particles every step
        <br/>
        part_emitter_stream(global.P_System, global.Particle1_Emitter1, global.Particle1, 10);
        <br/>
        <br/>
        // This can now be forgotten as it will function until told to stop...
        <br/>
        // Set the alarm[0] event to burst the emitter2 particles...
        <br/>
        alarm[0] = 30; </p>
      <p class="dropspot"><img>Итак, здесь мы создаем два излучателя частиц, которые назначаются системе частиц, созданной нами в самом начале. Функции/действия для создания этих излучателей позволяют нам определить область в комнате, над которой они будут излучать частицы, а также указать тип излучаемых частиц, их форму и распределение в заданной области. Функции/действия возвращают числовое значение, которое является идентификатором излучателя, и мы сохраняем его в переменной, чтобы использовать дальнейшие функции излучателей для нацеливания на эти излучатели.</p>
      <p class="dropspot">Теперь у нас есть код/GML Visual для потоковой передачи частиц (эти частицы будут испускаться каждый шаг игры без нашего участия), но мы также хотим добавить <strong>событие</strong><strong>Alarm[0]</strong>, чтобы частицы вырывались через определенные промежутки времени:</p>
      <p class="code">part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x - 10, mouse_x + 10, mouse_y - 10, mouse_y + 10, ps_shape_ellipse, ps_distr_gaussian);
        <br/>
        part_emitter_burst(global.P_System, global.Particle1_Emitter2, global.Particle1, 30);
        <br/>
        alarm[0] = 30;</p>
      <p class="dropspot"><img>Всплеск частиц - это просто единовременный взрыв частиц из излучателя, а не постоянный поток их на каждом шаге игры.</p>
      <p class="dropspot">Но что если вы хотите, чтобы несколько объектов испускали частицы? Глобальный эмиттер может одновременно находиться только в одном месте, поэтому вам нужно будет создать <em>локальные </em>эмиттеры в каждом объекте. Эти эмиттеры будут по-прежнему использовать глобальную систему частиц и любые частицы, находящиеся в ней, но они могут быть разных форм и размеров и перемещаться вместе с объектом, что делает их идеальными для ракет, пуль и прочего. Код, который вы будете использовать, точно такой же, как и выше, но без префикса &quot;global&quot; перед именами эмиттеров.</p>
      <p class="dropspot">С созданием частиц разобрались, но есть еще одна вещь, которая очень важна... Очистка, когда вы закончите с ними.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Уборка</a></p>
    <div class="droptext" data-targetname="drop-down4">
      <p class="dropspot">Как уже упоминалось в начале, после создания система частиц (и ее частицы, эмиттеры и т.д.) сохраняется в памяти для мгновенного использования. Отлично, но что произойдет, если вы перезапустите игру? Или если ваш игрок умрет и начнет комнату заново? Если вы не будете правильно управлять игрой, вы получите утечку <strong>памяти</strong>. Это когда что-то было создано и использует память, но было &quot;отнесено&quot;, то есть <span class="notranslate">GameMaker</span> больше не имеет к нему доступа. Такие вещи будут медленно съедать память и вызывать задержки в игре или даже блокировать компьютер, что приведет к краху игры, и это довольно распространенная проблема у начинающих пользователей систем частиц.</p>
      <p class="dropspot">Как избежать этого? В <span data-keyref="GameMaker Name">GameMaker</span> есть функции <span class="notranslate">GML</span> Code и <span class="notranslate">GML</span> Visual actions для удаления систем частиц, их излучателей и частиц из памяти, когда они не используются, и при небольшом планировании при использовании следующего кода/действий вы можете легко предотвратить эту потенциальную проблему.</p>
      <p class="dropspot">Прежде всего, вам нужно решить, где вы собираетесь создать систему и как вы будете ее использовать. Вы можете создать глобальную систему в <strong>событии начала игры</strong> объекта, который находится в вашей первой комнате (например, меню или титульный экран), но это означает, что если вы перезапустите игру с помощью функции <a href="../GameMaker_Language/GML_Reference/General_Game_Control/game_restart.htm"><span class="inline">game_restart()</span></a> функция будет создана заново и вызовет утечку памяти. Или вы можете создать локальную систему в экземпляре в любой комнате, но опять же, если вы покинете комнату, система будет недоступна и вызовет утечку памяти. Чтобы избежать этого, вам нужно иметь что-то вроде этого в параметре <a href="../The_Asset_Editors/Object_Properties/Other_Events.htm"><strong>Мероприятие по окончанию игры</strong></a> или <a href="../The_Asset_Editors/Object_Properties/Object_Events.htm"><strong>Событие очистки</strong></a> вашего объекта:</p>
      <p class="code">part_type_destroy(global.Particle1);
        <br/>
        part_emitter_destroy(global.P_System, global.Particle1_Emitter);
        <br/>
        part_emitter_destroy(global.P_System, global.Particle2_Emitter);
        <br/>
        part_system_destroy(global.P_System);</p>
      <p class="dropspot"><img>Это удалит определенные частицы, излучатели, а затем и систему из памяти, чтобы вы могли перезапустить игру или сменить комнату. Помните, что после размышлений о том, где будет наиболее подходящее место для создания системы, подумайте также о том, где будет наиболее подходящее место для ее уничтожения!</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p>Теперь вы знаете основы о частицах, системах частиц и эмиттерах, так что теперь вы можете добавить их в свою игру! Но прежде чем бросаться добавлять эффекты частиц во все подряд, обратите внимание, что хотя частицы менее требовательны к процессору, чем инстансы, они не являются решением всех проблем, так как при одновременном использовании тысяч частиц они будут вызывать лаг. Лучше всего экспериментировать и использовать их осторожно, чтобы визуально &quot;оживить&quot; игру и придать ей больше привлекательности, не переусердствуя при этом.</p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
          <div style="float:right">Следующее: <a href="Guide_To_Using_Shaders.htm">Руководство по использованию шейдеров</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
    </div>
    <!-- KEYWORDS
Vectors
Vector Maths
--><!-- TAGS
vector_maths
--></body>
</html>