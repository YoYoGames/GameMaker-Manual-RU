<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Руководство по использованию буферов</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how buffers work" />
  <meta name="rh-index-keywords" content="Guide To Using Buffers" />
  <meta name="search-keywords" content="Using Buffers,buffers" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Руководство по использованию буферов</h1>
  <p>Буфер (в программировании) - это пространство в системной памяти, которое используется для хранения небольших пакетов данных практически для всего (например: передача данных, столкновения, данные о цвете и т.д.). Поскольку он хранится в системной памяти, доступ к нему осуществляется очень быстро, и буфер обычно используется для очень краткосрочного хранения, например, для получения сетевой информации перед ее обработкой или для хранения контрольной точки в вашей игре (это объясняется в примере, приведенном далее на странице).</p>
  <p><img>Буферы создаются путем выделения места в системной памяти, исчисляемого в <span class="glossextra">байтах</span>, которое затем резервируется для вашей игры, пока игра запущена или пока вы не удалите буфер с помощью соответствующей функции (вы можете найти все функции буфера <span class="notranslate">GML</span>, перечисленные <a href="../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">здесь</a>). Это означает, что даже когда ваша игра не находится в фокусе (например, на мобильном устройстве, когда вы принимаете звонок, игра переходит в фоновый режим), буфер все еще будет существовать, однако если игра будет закрыта или запущена заново, буфер будет потерян.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Перезапуск игры не очистит и не удалит буфер! Но это предотвратит дальнейший доступ к ранее созданному буферу, так как ID handle будет потерян, что вызовет утечку памяти, которая в конечном итоге приведет к краху вашей игры. Поэтому, перезапуская игру, не забудьте сначала удалить все буферы.</p>
  <p><span data-keyref="GameMaker Name">GameMaker</span> позволяет создавать четыре различных типа буферов. Причина этого заключается в том, что буферы предназначены для высоко оптимизированного временного хранения данных, и поэтому вы должны создавать буфер, соответствующий типу данных, которые вы хотите в нем хранить, иначе вы можете получить ошибки или вызвать узкое место в вашем коде. Прежде чем объяснять это дальше, давайте рассмотрим четыре доступных типа буферов (определенные как <strong>константы </strong>в <span class="notranslate">GML</span>):</p>
  <p> </p>
  <table>
    <tbody>
      <tr>
        <th>Постоянная</th>
        <th>описание</th>
      </tr>
      <tr>
        <td><span class="notranslate"><span class="inline">buffer_fixed</span></td>
        <td><br>
          Буфер фиксированного размера в байтах. Размер устанавливается при создании буфера и больше не может быть изменен.</td>
      </tr>
      <tr>
        <td><span class="notranslate"><span class="inline">buffer_grow</span></td>
        <td><br>
          Буфер, который будет динамически <i>увеличиваться</i> по мере добавления данных. Вы создаете его с начальным размером (который должен быть приблизительно равен размеру данных, которые предполагается хранить), а затем он будет расширяться, принимая данные, превышающие этот начальный размер.</td>
      </tr>
      <tr>
        <td><span class="notranslate"><span class="inline">buffer_wrap</span></td>
        <td><br>
          Буфер, в который будут <i>заворачиваться</i> данные. Когда добавляемые данные достигнут предела размера буфера, перезапись будет помещена обратно в начало буфера, и дальнейшая запись продолжится с этого момента.</td>
      </tr>
      <tr>
        <td><span class="notranslate"><span class="inline">buffer_fast</span></td>
        <td><br>
          Это специальный &quot;урезанный&quot; буфер, который очень быстро читается и записывается. Однако он может использоваться только с типами данных <span class="inline"><span class="inline">buffer_u8</span> и должен быть выровнен по 1 байту. (Информацию о <b>типах данных</b> и <b>выравнивании байтов</b> можно найти далее на этой странице).</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <p>Таковы типы буферов, доступные вам при работе с <span data-keyref="GameMaker Name">GameMaker</span>, и выбор буфера во многом зависит от того, для каких целей вы хотите его использовать. Например, растущий буфер будет использоваться для хранения &quot;снимка&quot; данных для создания сохранения игры, поскольку вы не знаете фактического объема данных, которые будут в него помещены, или быстрый буфер будет использоваться, когда вы знаете, что все значения, с которыми вы работаете, находятся в диапазоне от 0 до 255 или от -128 до 127, например, при обработке данных <a class="glossterm" data-glossterm="ARGB" href="#">ARGB</a> из изображения.</p>
  <p><img>При создании буфера вы всегда должны стараться создать его такого размера, который соответствует типу, при этом общее правило заключается в том, что он должен быть создан для максимального размера данных, которые он должен хранить, а если есть сомнения, используйте растущий буфер для предотвращения ошибок перезаписи.</p>
  <p>Фактический код для создания буфера будет выглядеть примерно так:</p>
  <p class="code">player_buffer = buffer_create(16384, buffer_fixed, 2);</p>
  <p><br>
    Это создаст фиксированный буфер размером 16384 байта с выравниванием по байтам до 2, при этом функция возвращает уникальное значение ID, которое хранится в переменной для последующего обращения к этому буферу.</p>
  <p>При чтении и записи данных в буфер, вы делаете это &quot;кусками&quot; данных, определяемыми их &quot;типом данных&quot;. Тип данных&quot; задает количество байт, выделяемых в буфере для записываемого значения, и очень важно, чтобы это было правильно, иначе вы получите очень странные результаты (или даже ошибки) для вашего кода.</p>
  <p>Запись в буфер (и чтение из него) происходит <strong>последовательно</strong>, то есть одна часть данных записывается за другой, причем каждая часть данных имеет определенный тип. Это означает, что в идеале вы должны постоянно знать, какие данные вы записываете в буфер. Эти типы данных определяются в <span class="notranslate">GML</span> следующими константами:</p>
  <p> </p>
  <table>
    <tbody>
      <tr>
        <th>Тип данных Константа</th>
        <th>Байты</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td><span class="inline">buffer_u8</span></td>
        <td>1</td>
        <td><br>
          Беззнаковое 8-разрядное целое число. Это положительное значение от 0 до 255.</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_s8</span></td>
        <td>1</td>
        <td><br>
          Знаковое 8-разрядное целое число. Это может быть положительное или отрицательное значение от -128 до 127 (0 считается положительным).</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_u16</span></td>
        <td>2</td>
        <td><br>
          Беззнаковое 16-разрядное целое число. Это положительное значение от 0 до 65 535.</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_s16</span></td>
        <td>2</td>
        <td><br>
          Подписанное 16-разрядное целое число. Это может быть положительное или отрицательное значение от -32,768 до 32,767 (0 считается положительным).</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_f16</span></td>
        <td>2</td>
        <td><br>
          16-разрядное число с плавающей запятой. Это может быть положительное или отрицательное значение в диапазоне +/- 65504. <b>(В настоящее время не поддерживается!)</b></td>
      </tr>
      <tr>
        <td><span class="inline">buffer_u32</span></td>
        <td>4</td>
        <td><br>
          Беззнаковое 32-разрядное целое число. Это положительное значение от 0 до 4 294 967 295.</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_s32</span></td>
        <td>4</td>
        <td><br>
          Подписанное 32-разрядное целое число. Это может быть положительное или отрицательное значение от -2,147,483,648 до 2,147,483,647 (0 считается положительным).</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_f32</span></td>
        <td>4</td>
        <td><br>
          32-разрядное число с плавающей запятой. Это может быть положительное или отрицательное значение в диапазоне +/-16777216.</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_u64</span></td>
        <td>8</td>
        <td><br>
          64-битное беззнаковое целочисленное значение.<b>(В настоящее время поддерживается не всеми функциями буфера!)</b></td>
      </tr>
      <tr>
        <td><span class="inline">buffer_f64</span></td>
        <td>8</td>
        <td><br>
          64-разрядное число с плавающей запятой.</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_bool</span></td>
        <td>1</td>
        <td><br>
          Булево значение. Может быть только 1 или 0 (<span class="inline">true</span> или <span class="inline">false</span>).</td>
      </tr>
      <tr>
        <td><span class="inline">buffer_string</span></td>
        <td>Н/Д</td>
        <td><br>
          Это строка UTF-8 с нулевым окончанием (0x00). По сути, в буфер сбрасывается строка <span class="notranslate">GameMaker</span>, а в конце ставится 0.</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <p>Итак, допустим, вы создали буфер и хотите записать в него информацию, тогда вы используете что-то вроде следующего кода:</p>
  <p class="code">buffer_write(buff, buffer_bool, global.Sound);<br />
    buffer_write(buff, buffer_bool, global.Music);<br />
    buffer_write(buff, buffer_s16, obj_Player.x);<br />
    buffer_write(buff, buffer_s16, obj_Player.y);<br />
    buffer_write(buff, buffer_string, global.Player_Name);</p>
  <p>Рассмотрев приведенный выше пример, можно увидеть, что в буфер можно одновременно записывать различные типы данных (при использовании <em>быстрого </em>типа буфера вы ограничены только определенным типом данных), и эти данные будут добавляться в буфер последовательно (хотя их фактическое положение в буфере будет зависеть от их выравнивания по байтам, о чем будет сказано ниже). То же самое относится и к чтению информации из буфера, и в случае приведенного выше примера вы будете читать из буфера в том же порядке, в котором записывали данные, проверяя их на одинаковый тип, например</p>
  <p class="code">global.Sound = buffer_read(buff, buffer_bool);<br />
    global.Music = buffer_read(buff, buffer_bool);<br />
    obj_Player.x = buffer_read(buff, buffer_s16);<br />
    obj_Player.y = buffer_read(buff, buffer_s16);<br />
    global.Player_Name = buffer_read(buff, buffer_string);</p>
  <p>Как вы видите, вы считываете информацию в том же порядке, в котором вы считываете ее в буфер. Для получения дополнительной информации о том, как добавлять и удалять данные из буфера, смотрите примеры, приведенные ниже.</p>
  <p>Если вы читали эту страницу, то наверняка видели упоминания о <strong>выравнивании байтов </strong>в буфере. В основном это относится к позиции, в которой новые данные будут храниться в данном буфере. Как это работает? Для буфера с выравниванием по одному байту каждый фрагмент данных записывается в буфер последовательно, причем каждый новый фрагмент данных добавляется непосредственно после предыдущего. Однако буфер с выравниванием по 2 байтам будет записывать каждый фрагмент данных с интервалом в 2 байта, так что даже если ваша первоначальная запись составляет 1 байт данных, следующая запись будет перемещена для выравнивания по двум байтам:</p>
  <p><img>Так, если ваше выравнивание по байтам установлено, скажем, на 4 байта, и вы записываете один фрагмент данных размером в 1 байт, затем выполняете буфер <strong>tell </strong>(буфер tell получает текущую позицию для чтения/записи для буфера), вы получите <strong>смещение </strong>в 1 байт (смещение в данном случае - это количество байт от начала буфера до текущей позиции чтения/записи).</p>
  <p>Однако если вы запишете еще один фрагмент данных размером в 1 байт, <em>а затем </em>выполните буфер tell, вы получите смещение в 5 байт (даже если вы записали только 2 байта данных), так как выравнивание добавило данные, чтобы выровнять их с выравниванием буфера в 4 байта.</p>
  <p>По сути, это означает, что выравнивание влияет только на то <em>, куда </em>записываются данные, поэтому если после записи чего-либо вы сделаете буфер tell, он вернет текущую позицию записи, которая следует сразу за данными, которые вы ранее записали. Обратите внимание, однако, что если после этого вы запишете еще один фрагмент данных, буфер с внутренней стороны переместит позицию записи на следующую кратную величину выравнивания, прежде чем записать этот фрагмент данных.</p>
  <p>Ниже мы приводим несколько примеров использования буферов в проекте:</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Контрольная точка буфера</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Простым примером использования буфера в игре <span data-keyref="GameMaker Name">GameMaker</span> для любой платформы является функция <a href="../GameMaker_Language/GML_Reference/General_Game_Control/game_save_buffer.htm"><span class="inline">game_save_buffer()</span></a>. Эта функция делает &quot;снимок&quot; текущего состояния игры и сохраняет его в заранее определенном буфере, который затем может быть прочитан, чтобы снова загрузить игру в этот момент.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Эта функция очень ограничена и предназначена для новичков, чтобы быстро запустить систему контрольных точек, но более опытные пользователи могут предпочесть кодировать свою собственную систему, используя функции File, из-за того, что игра не будет сохранять динамические ресурсы, которые вы можете создавать во время выполнения, такие как структуры данных, поверхности, добавленные <span class="notranslate">sprites</span> и т.д..</p>
    <p class="dropspot">Первое, что нам нужно сделать, это создать новый объект для управления сохранением и загрузкой, поэтому создайте его и дайте ему <strong>событие Create</strong>. В этом событии вы можете разместить следующий код:</p>
    <p class="code">SaveBuffer = buffer_create(1024, buffer_grow, 1);<br />
      StateSaved = false;</p>
    <p class="dropspot">Первая строка создает растущий буфер (поскольку мы не знаем окончательного размера сохраненных данных) размером 1024 байта с выравниванием по 1 байту. Затем создается переменная для проверки, была ли игра сохранена или нет (она будет использоваться для загрузки).</p>
    <p class="dropspot">Далее мы добавим <strong>событие нажатия клавиш</strong> (например, <strong>Keypress Event</strong> ), в котором мы сохраним текущее состояние игры в созданный буфер:</p>
    <p class="code">StateSaved = true;<br />
      buffer_seek(SaveBuffer, buffer_seek_start, 0);<br />
      game_save_buffer(SaveBuffer);</p>
    <p class="dropspot">Приведенные выше действия сначала установят управляющую переменную в <span class="inline">true </span>(чтобы она сохранилась при сохранении игры в буфер), а затем обратятся к началу буфера перед записью в него текущего состояния сохранения. Почему мы используем <a href="../GameMaker_Language/GML_Reference/Buffers/buffer_seek.htm"><span class="inline">buffer_seek()</span></a>? Как уже упоминалось на этой странице, вы читаете и записываете в буфер с последней позиции, с которой в него были добавлены данные. Это означает, что если вы не установите буфер tell обратно в начало, то при сохранении вы будете добавлять данные в буфер в текущей позиции чтения/записи буфера. Поэтому мы используем функцию <span class="inline">buffer_seek()</span>, чтобы переместить tell в начало буфера.</p>
    <p class="dropspot">Теперь мы сохранили текущее состояние игры в буфер. Следующим шагом будет разработка кода для его загрузки, возможно, в другом <strong>событии Keypress Event</strong>:</p>
    <p class="code">if StateSaved<br />
      {<br />
          buffer_seek(SaveBuffer, buffer_seek_start, 0);<br />
          game_load_buffer(SaveBuffer);<br />
      }</p>
    <p class="dropspot">Игра будет загружена в конце события, в котором вы разместите приведенный выше код.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Это только для использования в одной комнате, а не для создания полных сохраненных игр после закрытия или перезапуска игры!</p>
    <p class="dropspot">Последнее, что нужно добавить в объект контроллера, - это код &quot;очистки&quot;. Буферы хранятся в памяти, и поэтому, если вы не очистите их после завершения работы с ними, вы можете получить утечку памяти, которая в конечном итоге приведет к лагам и краху вашей игры. Поэтому вы, вероятно, добавите <strong>событие Room End Event</strong> (из категории <strong>Other</strong> event) с:</p>
    <p class="code">buffer_delete(SaveBuffer);</p>
    <p class="dropspot">Теперь этот объект можно поместить в комнату и по нажатию клавиши сохранить и загрузить состояние комнаты из буфера.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Сетевые буферы</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">При работе с <a href="../GameMaker_Language/GML_Reference/Networking/Networking.htm">сетевыми функциями</a> <span data-keyref="GameMaker Name">GameMaker</span> вам придется использовать буферы для создания пакета данных, который передается по сетевому соединению. Этот пример призван показать, как это делается, но из-за широких возможностей сетевых функций он предназначен только для того, чтобы показать, как использовать сами буферы, а не всю сетевую систему.</p>
    <p class="dropspot">Первое, что мы покажем, это создание и использование буфера для клиентской стороны сетевого соединения. Этот буфер будет использоваться для создания небольших пакетов данных, которые затем могут быть отправлены на сервер, поэтому в <strong>событии Create</strong> экземпляра мы назначим буфер следующим образом:</p>
    <p class="code">send_buff = buffer_create(256, buffer_grow, 1);</p>
    <p class="dropspot">Мы делаем буфер небольшим (256 байт) - поскольку он не предназначен для хранения большого количества данных - затем мы делаем его растущим буфером, чтобы гарантировать отсутствие ошибок, если нам понадобится добавить больше данных для отправки в любое время, а выравнивание установлено на единицу для удобства.</p>
    <p class="dropspot">Теперь предположим, что мы хотим, чтобы наш клиент отправлял данные на сервер. Для этого нам нужно создать буферный &quot;пакет&quot;, и в этом примере мы собираемся отправить <strong>событие нажатия клавиши</strong>, например, когда игрок нажимает <em>стрелку влево </em>для перемещения по игре. Для этого мы сначала запишем необходимые данные в буфер, а затем отправим их:</p>
    <p class="code">buffer_seek(buff, buffer_seek_start, 0);<br />
      buffer_write(buff, buffer_u8, 1);<br />
      buffer_write(buff, buffer_s16, vk_left);<br />
      buffer_write(buff, buffer_bool, true);<br />
      network_send_packet(client, buff, buffer_tell(buff));</p>
    <p class="dropspot">Перед записью в буфер мы установили &quot;tell&quot; в начало буфера, так как networking всегда берет данные из начала буфера. Затем мы записываем контрольное значение (оно будет использоваться сервером для определения типа обрабатываемого события), затем используемую клавишу, а затем состояние клавиши (в данном случае true для нажатой). Этот буфер затем отправляется сетевой функцией в виде пакета данных. Обратите внимание, что мы не отправляем весь буфер! Мы отправляем только записанные данные, используя функцию buffer_tell для возврата текущей позиции чтения/записи в буфере (помните, что запись в буфер перемещает &quot;tell&quot; в конец того, что было записано). Это делается просто для того, чтобы избежать отправки большего количества байт, чем необходимо.</p>
    <p class="dropspot">А как насчет получения данных на сервере? Полученный пакет данных должен быть записан в буфер на сервере и затем использован для обновления игры. Для этого мы будем использовать <a href="../The_Asset_Editors/Object_Properties/Async_Events.htm">асинхронное событие Networking</a> в объекте сетевого контроллера сервера, как показано в этом упрощенном коде ниже:</p>
    <p class="code">var buff = ds_map_find_value(async_load, &quot;buffer&quot;);<br />
      if (cmd == buffer_read(buff, buffer_u8)) <br />
      {<br />
          key = buffer_read(buff, buffer_s16);<br />
          key_state = buffer_read(buff, buffer_bool);<br />
      }</p>
    <p class="dropspot">Асинхронное событие будет содержать специальную временную карту DS <span class="inline">async_load</span> (она удаляется из памяти по окончании события автоматически), которая содержит различную информацию в зависимости от типа входящих данных из сети. В данном случае мы предполагаем, что карта была проверена и оказалась буферным пакетом данных, отправленным от клиента. Теперь мы проверяем первую часть данных, которая находится в буфере, чтобы увидеть, какой тип события был отправлен - в данном случае значение &quot;1&quot; представляет собой событие нажатия клавиши, однако при кодировании таких вещей вы должны определить константы для хранения этих значений, чтобы упростить работу - и затем сохранить нажатую клавишу и ее состояние (<span class="inline">true</span> = нажата, <span class="inline">false</span> = отпущена). Эта информация затем будет использоваться для обновления всех клиентов с новым статусом игрока отправляющего клиента.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Буфер, который создается из карты DS, автоматически удаляется в конце сетевого асинхронного события, поэтому здесь нет необходимости использовать <span class="inline" style="font-size: 14px">buffer_delete()</span>.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующее: <a href="Bitwise_Operators.htm">Побитовые операторы</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Buffers
Using Buffers
-->
  <!-- TAGS
using_buffers
-->
</body>
</html>