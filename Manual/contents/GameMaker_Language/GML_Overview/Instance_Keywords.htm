<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Ключевые слова экземпляра</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Ключевые слова экземпляра</h1>
    <p>Чтобы упростить некоторые вещи в <span data-keyref="GameMaker Name">GameMaker</span>, вы можете использовать одно из нескольких <b>ключевых слов instance</b> в своем коде (будь то <span class="notranslate">GML</span> или <span class="notranslate">GML</span> Visual). Эти ключевые слова используются в основном для идентификации экземпляров - а в некоторых случаях и структур - в различных ситуациях, и каждое из них объясняется в тексте ниже.</p>
    <p>Обратите внимание, что все приведенные ключевые слова внутри программы представлены <strong>отрицательными целочисленными значениями</strong>, поэтому следует соблюдать осторожность при присвоении или проверке значений переменных с этими ключевыми словами, так как впоследствии вы можете получить неожиданные результаты, поскольку <span data-keyref="GameMaker Name">GameMaker</span> интерпретирует использованное вами значение как нечто иное. Следует также отметить, что использование в коде непосредственно целочисленных значений вместо ключевых слов <b>вообще не рекомендуется</b> и может вызвать проблемы в дальнейшем.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Ключевое слово</th>
            <th>Описание</th>
            <th>значение</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>Экземпляр/структура, выполняющая текущий блок кода.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> можно использовать для идентификации текущей структуры или экземпляра, который находится в области видимости в текущем блоке кода. Например:</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">В этом примере видно, что у нас есть <i>локальная</i> переменная <span class="inline">val</span>, и мы хотим, чтобы она установила переменную <i>экземпляра</i> с тем же именем во вновь созданном экземпляре объекта. Чтобы правильно определить переменную экземпляра и указать <span data-keyref="GameMaker Name">GameMaker</span> установить ее в экземпляре, вызывающем блок кода, мы используем ключевое слово <span class="inline">self</span>. В большинстве случаев вместо <span class="inline">self</span> можно также использовать встроенную переменную экземпляра <span class="inline">id</span>, но <span class="inline">self</span> имеет определенные преимущества. Во-первых, компилятор быстрее определяет экземпляр (или структуру), используя <span class="inline">self</span>, а не <span class="inline">id</span>, так как значение <span class="inline">id</span> проходит через таблицу поиска экземпляра, а <span class="inline">self</span> - нет. Во-вторых, для тех, кто создает расширения, очень полезно обеспечить правильную привязку переменных, поскольку возможно, что проект, использующий расширение, может иметь переменную глобальной области видимости или что-то с тем же именем, что и переменная в расширении.</p>
      <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Ключевое слово <span class="inline">self</span> <strong>не </strong>является сокращением для фактического значения ID экземпляра или структуры и должно использоваться только в контексте, описанном выше. Если вам требуется <strong>значение </strong>ID для экземпляра, то необходимо использовать <span class="inline">self.id</span>, например:</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">Стоит также отметить, что <span class="inline">self</span> может также использоваться внутри <a href="Structs.htm">структур</a> - при очень специфических обстоятельствах - для ссылки на переменные-члены структуры.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Ключевое слово</th>
            <th>Описание</th>
            <th>значение</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>Другой экземпляр, участвующий в событии столкновения, в функции <span class="inline">with</span> или в функции.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Специальное ключевое слово <span class="inline">other</span> имеет несколько способов использования для ссылки на конкретный экземпляр (а в некоторых случаях и на структуру): оно может быть использовано в операторе <span class="inline">with</span> (объясняется <a href="Language_Features/with.htm">здесь</a>), в <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">событии столкновения</a> или в функции. В этом разделе мы объясним два последних случая использования.</p>
      <p class="dropspot">Обратите внимание, что в событиях, отличных от события столкновения, вне любых вызовов функций и блоков <span class="inline">with()</span>, <span class="inline">other</span> просто возвращает struct для текущего экземпляра.</p>
      <h2 class="dropspot">Событие столкновения</h2>
      <p class="dropspot">Событие столкновения может произойти только между <strong>двумя </strong>экземплярами. Вы <i>можете</i> иметь несколько столкновений между несколькими экземплярами, но все они решаются <span data-keyref="GameMaker Name">GameMaker</span> по принципу &quot;один на один&quot;, с экземпляром &quot;себя&quot;, у которого произошло событие столкновения, и экземпляром &quot;другого&quot;, который с ним столкнулся.</p>
      <p class="dropspot">Представьте, что у вас есть экземпляр игрока, несколько экземпляров врагов и несколько экземпляров пуль, которыми враги могут стрелять в вас. Вы можете назначить каждому врагу один экземпляр пули, но с другой переменной урона, случайно назначаемой ему при создании, например:</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Вы можете видеть, как мы задаем его переменные, используя точечную нотацию, как описано в разделе " <a href="Addressing_Variables_In_Other_Instances.htm">Обращение к переменным в других экземплярах</a>". Это даст каждому экземпляру пули свое значение урона, но как игрок определит урон, который он должен получить при попадании в него пули?</p>
      <p class="dropspot">Для этого игроку нужно будет создать событие столкновения с <span class="inline">obj_Bullet</span>, а внутри этого события использовать <span class="inline">other</span> для чтения переменных из экземпляра столкнувшейся пули:</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">Приведенный выше код вычитает из переменной &quot;hp&quot; игрока сумму, хранящуюся в переменной &quot;damage&quot; <i>другого</i> экземпляра, затем проверяет, меньше ли &quot;hp&quot; или равно 0. Если да, то уничтожает экземпляр игрока. Обратите внимание, что у другого экземпляра должна быть проверяемая переменная, иначе будет выдана ошибка.</p>
      <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Событие "Столкновение" - единственное событие, в котором ключевое слово <span class="inline">other</span> имеет особое значение. Во всех остальных событиях и сценариях поведение <span class="inline">other</span> определяется контекстом, в котором оно используется (например, блок <span class="inline">with() </span>, функция, объявление структуры и т.д.).</p>
      <p class="dropspot">Вы можете присваивать значения переменным или даже создавать новые, используя <span class="inline">other</span> в событии столкновения, как показано ниже:</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Декларация структуры</h2>
      <p class="dropspot">При использовании внутри объявления struct, <span class="inline">other</span> относится к экземпляру, который инициализирует struct:</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Однако вам не нужно использовать <span class="inline">other</span> для чтения переменных из экземпляра, поскольку любые переменные, на которые вы ссылаетесь напрямую, будут прочитаны из области видимости этого экземпляра, как описано <a href="Structs.htm#inst_in_struct">в этом разделе</a> руководства. Это необходимо только в том случае, если вы хотите сохранить ссылку на struct этого экземпляра.</p>
      <h2 class="dropspot">Метод экземпляра</h2>
      <p class="dropspot">Использование <span class="inline">other</span> внутри метода другого экземпляра <a href="Method_Variables.htm"><span class="notranslate">method</span></a> относится к экземпляру, который вызвал этот метод.</p>
      <p class="dropspot">Например, допустим, на сайте <span class="inline">Object2</span> есть метод, который ссылается на <span class="inline">self</span> и <span class="inline">other</span>. Затем этот метод вызывается в <span class="inline">Object1</span>. Поскольку метод был создан в <span class="inline">Object2</span>, он <strong>привязан</strong> к нему и всегда будет использовать экземпляр <span class="inline">Object2</span> в качестве &quot;себя&quot;, независимо от того, какой экземпляр его вызывает. В этом случае вызывающий экземпляр становится <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Это приведет к тому, что экземпляр сначала выведет свое собственное имя объекта (&quot;Object2&quot;), а затем имя объекта вызывающего экземпляра (&quot;Object1&quot;).</p>
      <p class="dropspot">То же самое относится и к методу, привязанному к struct.</p>
      <h2 class="dropspot">Функция конструктора</h2>
      <p class="dropspot">При использовании в функции конструктора <span class="inline">other</span> будет ссылаться на экземпляр, вызывающий эту функцию, однако это не рекомендуется для общего использования, поскольку любые внешние данные, которые конструктор должен использовать, должны быть переданы в качестве аргументов.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Ключевое слово</th>
            <th>Описание</th>
            <th>значение</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Все экземпляры, активные в данный момент в комнате.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Это ключевое слово используется для указания <span data-keyref="GameMaker Name">GameMaker</span>, что функция должна быть применена или проверена ко всем активным экземплярам в комнате (деактивированные экземпляры не будут проверяться или к ним не будет доступа). Вы <b>не можете</b> использовать <span class="inline">all</span> для доступа или установки переменных в других экземплярах с помощью метода point (см. <a href="Addressing_Variables_In_Other_Instances.htm">здесь</a>), но вы <strong>можете </strong>использовать его при вызове функции. <a href="Language_Features/with.htm"><span class="inline">with()</span></a>например:</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">Приведенный выше код установит скорость всех экземпляров в комнате на 0. Вы также можете использовать <span class="inline">all</span> внутри функций, чтобы, например, нацелить или проверить все экземпляры в комнате:</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> является очень полезным ключевым словом и может использоваться во многих ситуациях в коде и действиях, часто сокращая объем кода, который необходимо написать для достижения желаемого эффекта.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Ключевое слово</th>
            <th>Описание</th>
            <th>значение</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>Ни одного экземпляра.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Это может показаться странным, но много раз при программировании игр вы столкнетесь с необходимостью проверить, нет ли экземпляров, найденных в определенном месте, или в столкновении и т.д.. В этих случаях вы можете использовать это ключевое слово, чтобы проверить, что ничего нет, примерно так:</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">В этом примере функция <span class="inline">instance_nearest()</span> вернет либо <span class="inline">noone</span>, либо уникальный ID ближайшего найденного экземпляра. В принципе, в любой момент, когда вам нужно проверить наличие экземпляра, вы можете ожидать возврата либо <span class="inline">noone</span>, либо уникального идентификатора экземпляра.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Назад: <a href="GML_Overview.htm">Обзор GML</a></div>
          <div style="float:right">Следующее: <a data-xref="{title}" href="Evaluation_Order.htm">Порядок оценки</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>