<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Аксессоры</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Аксессоры</h1>
  <p>Сайт <span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>) также позволяет вам получать доступ к определенным <a href="../GML_Reference/Data_Structures/Data_Structures.htm">структурам данных</a> и <a href="Arrays.htm">массивам</a> с помощью логических выражений, называемых <b>аксессорами</b>. Это построено так же, как и при обычной работе с массивом, только перед первым аргументом мы используем <em>символ идентификатора</em>, чтобы сообщить <span data-keyref="GameMaker Name">GameMaker</span>, что вы работаете с (ранее созданной) структурой данных или литералом массива.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Списки DS [| ]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot">Синтаксис для <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">списков DS</a> следующий:</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">Поэтому, когда вы используете <span class="inline">ds_list_create()</span> для создания списка, вы используете индекс списка (который вы сохранили в переменной) для ссылки на него, при этом значение &quot;индекс&quot; является позицией в списке для установки или добавления. Например, следующий код создает список, а затем добавляет 10 записей, устанавливая для каждой записи случайное число от 0 до 9:</p>
    <p class="code">ds = ds_list_create();<br />
      var index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">Обратите внимание, что если вы используете выражение для добавления ссылки на индекс, который уже имеет значение, предыдущее значение будет заменено, а не добавлен новый индекс в список. Чтобы добавить дополнительные записи, необходимо знать размер списка ds_list и добавить их в конец. Также стоит отметить, что вы можете задать индекс списка, который <i>больше</i> размера списка, на который ссылаются, и в этом случае будет установлено это значение, одновременно расширяя список и инициализируя все позиции в списке до данного индекса как 0.</p>
    <p class="dropspot">После того как вы создали структуру списка и заполнили ее данными, для получения значений из списка вам потребуется что-то вроде:</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">Вышеприведенная функция получит значение из позиции 5 (шестой индекс, так как списки начинаются с 0) и сохранит его в переменной. Если вы зададите позицию, которая находится за пределами размера списка, то будет возвращено значение <span class="inline">undefined</span>, что можно проверить с помощью функции <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Карты DS [?]</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">Синтаксис для <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">карт DS</a> следующий:</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot">После создания карты с помощью <span class="inline">ds_map_create()</span>, вы будете использовать индекс карты, который вы сохранили в переменной, чтобы ссылаться на нее, при этом значение &quot;key&quot; будет ключом карты, который нужно установить или получить. Например, следующий код создает карту, а затем добавляет в нее несколько записей, используя этот синтаксис:</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">Обратите внимание, что если карта уже содержит то же значение ключа, которое вы пытаетесь добавить, она не создаст дубликат ключа с новым значением, а заменит предыдущее значение.</p>
    <p class="dropspot">После того как вы создали структуру карты и заполнили ее данными, для получения значений по определенному ключу карты вы должны сделать следующее:</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">Приведенное выше действие позволит получить значение из ключа &quot;Name&quot; и сохранить его в переменной, но следует помнить, что если данный ключ не существует в карте DS, то возвращаемое значение будет <span class="inline">undefined</span>. Это можно проверить с помощью функции <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS Grids [# ]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">Синтаксис для <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DS grid</a> следующий:</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">После создания сетки с помощью функции <span class="inline">ds_grid_create()</span>, вы будете использовать индекс сетки, который вы сохранили в переменной, чтобы ссылаться на нее, а &quot;xpos&quot; и &quot;ypos&quot; будут позицией в сетке для получения или установки значения. Например, следующий код создает сетку, очищает ее до 0, затем добавляет в нее несколько записей:</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var gw = ds_grid_width(ds) - 1;<br />
      var gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var xx = irandom(gw);<br />
          var yy = irandom(gh);<br />
          if (ds[# xx, yy] == 0)<br />
          {<br />
              ds[# xx, yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">После того как вы создали структуру сетки и заполнили ее данными, для получения значений из определенной позиции сетки вы должны сделать следующее:</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">Вышеприведенное значение будет получено из заданной ds_grid на основе позиции мыши (разделенной на ширину &quot;ячейки&quot; в комнате, чтобы получить правильное местоположение). Если вы зададите позицию, которая находится вне границ сетки, то будет возвращено значение <span class="inline">undefined</span>, которое можно проверить с помощью функции <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Массивы [@ ]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Этот аксессор используется только в том случае, если включена <a href="../../Settings/Game_Options.htm">опция Copy on Write</a>.</p>
    <p class="dropspot">Массивы также имеют свои собственные аксессоры, которые работают аналогично перечисленным выше для структур данных. Однако аксессоры массивов обладают интересным свойством, которое позволяет изменять массив из <a href="Script_Functions.htm">функции скрипта</a> или <a href="Method_Variables.htm"><span class="notranslate">method</span></a> без необходимости его копирования. Когда вы передаете массив в функцию, он <strong>передается по ссылке</strong>, то есть сам массив не передается в скрипт, а на него просто ссылаются, чтобы получить данные. Обычно, если вам нужно изменить массив, он <em>копируется </em>в скрипт, а затем вам нужно передать обратно (вернуть) скопированный массив, чтобы исходный массив был обновлен. Это может привести к значительным накладным расходам на обработку, поэтому вместо этого можно использовать аксессор, который изменит исходный массив <em>напрямую </em>, без необходимости его копирования. Вы можете увидеть, как это работает, в примерах ниже.</p>
    <p class="dropspot">Синтаксис для массивов, использующий аксессор <span class="inline">@</span>, следующий:</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">После того как вы создали массив в экземпляре, вы можете передать его в сценарий по ссылке и использовать аксессор <span class="inline">@</span> для его непосредственного изменения. Например, вы создадите массив и вызовете функцию следующим образом:</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">Сама функция будет выглядеть примерно так:</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0; repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">Все, что делает эта функция, это выбирает 25 случайных позиций в массиве и устанавливает значение выбранной позиции массива равным 100.</p>
    <p class="dropspot">Конечно, аксессор <span class="inline">@</span> не требуется, если функция <strong>Copy on Write</strong> отключена.</p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Нельзя использовать аксессор массива <span class="inline">@</span> при работе с массивом <span class="inline">argument[n]</span> в функциях сценария.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Структуры [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>Синтаксис для <a href="Structs.htm">структур</a> следующий</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">Этот аксессор, по сути, является оберткой для функций <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> и <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, и вы будете использовать его так же, как аксессор для DS map. Например, если вы создали структуру и хотите получить значение из переменной под названием &quot;my_health&quot;, вы должны сделать следующее:</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">Как видите, вы передаете не саму переменную, а <em>строку</em> с ее именем. Обратите внимание, что если в структуре нет переменной с заданным именем, то аксессор вернет <span class="inline">undefined</span> в качестве значения.</p>
    <p class="dropspot">Чтобы задать переменную в структуре, нужно сделать следующее</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">Как и в случае с получением значения, вы указываете имя переменной для установки в виде строки, и она будет установлена в заданное значение. Если используемое имя переменной не существует в структуре, то она будет создана и установлена в заданное значение.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Важной особенностью аксессоров является то, что их можно объединять в <i>цепочки</i>. Это означает, что если у вас есть несколько вложенных структур данных и/или массивов, больше нет необходимости использовать множество функций для получения доступа к значению, которое находится глубоко во вложенной структуре. Например, у вас есть массив, и каждый элемент в массиве представляет собой список DS, например, так:</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>В приведенном выше коде мы создали массив из 3 элементов и назначили каждому из них список DS, а затем заполнили различные списки идентификаторами экземпляров различных объектов в игре. Теперь, чтобы получить доступ к ID в одном из списков, мы можем сделать следующее:</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>Однако вы можете сделать то же самое, используя цепочку аксессоров, гораздо более чистым способом, который использует меньше кода:</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>Таким образом можно объединить в цепочку несколько аксессоров, причем они могут быть разных типов, чтобы получить доступ к информации, хранящейся в каждой части вложенной структуры. Вот еще несколько примеров:</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>Использование цепочек аксессоров для вещей не только означает, что вы сможете писать более компактный код, но и позволит вам использовать итерацию (например, с помощью <a href="Language_Features/for.htm"><span class="inline">for</span></a> цикл) и другие техники для доступа к данным более чистым и интуитивно понятным способом.</p>
  <p>Стоит отметить, что при использовании аксессоров таким образом всегда следует использовать аксессор <span class="inline">@</span> для массивов, так как в противном случае вы будете добавлять дополнительные накладные расходы на любые выполняемые действия. Как упоминалось выше, по умолчанию массивы передаются в функции по ссылке и при изменении используют поведение &quot;копирование при записи&quot;. Однако если массив является частью цепочки, то предыдущий элемент в цепочке будет обновлен скопированным массивом, а &quot;оригинал&quot; будет удален. Например, если сделать примерно следующее:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>достигает тех же результатов, что и при выполнении этого действия:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>Однако второй пример лучше, поскольку он работает без лишних затрат на копирование всего массива.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="GML_Overview.htm">Обзор GML</a></div>
        <div style="float:right">Следующее: <a data-xref="{title}" href="Language_Features.htm">Особенности языка</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>