<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Массивы</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Массивы</h1>
  <p>Массивы могут быть чрезвычайно полезны и являются неотъемлемой частью создания игр. По сути, это тип переменной, которая может хранить несколько значений в виде &quot;списка&quot; - рассмотрим следующий код:</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>Используя синтаксис <span class="inline2">[item, item, item]</span>, мы создаем массив, который хранится в переменной. К элементам, хранящимся в массиве, в дальнейшем можно обращаться через эту переменную, используя целое число, начиная с <span class="inline">0</span>, которое помещается в скобки <span class="inline2">[]</span>:</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">Основной массив классифицируется как имеющий 1 <strong>размерность</strong>, но вы можете иметь массивы с более чем одной размерностью. В следующих разделах объясняются оба типа массивов:</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Одномерные массивы</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Прежде чем двигаться дальше, давайте уточним, что такое массив и как он устроен. Массив - это просто <a href="Data_Types.htm">тип данных</a>, который присваивается переменной, и он может содержать не только одно, но и несколько значений. На рисунке ниже показана схема базового массива:</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">Это называется <strong>1D</strong> (одномерный) массив, и, как вы видите, массив хранится в переменной &quot;<span class="inline">a</span>&quot; и содержит несколько значений. Чтобы получить доступ к массиву, нужно сделать примерно следующее:</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">Приведенный выше код получает значение из позиции 0 массива &quot;<span class="inline">a</span>&quot;, затем выводит его на консоль, которая, исходя из содержимого массива, показанного на рисунке выше, выведет 125. Если бы вы сделали следующее:</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">На выходе будет показано &quot;Привет!&quot;.</p>
    <p class="dropspot">Как вы видите, вы задаете массиву имя переменной, а затем значение в квадратных скобках <span class="inline">[]</span>, где значение - это позиция в массиве, из которой нужно получить данные. По сути, массив - это контейнер с определенным количеством слотов для хранения значений, и каждая позиция в контейнере имеет определенный номер для идентификации, который мы и поместили в <span class="inline">[]</span>. Стоит отметить, что содержимое массива <b>всегда начинается с 0</b> и <i>никогда не</i>может <i>быть отрицательным</i><em>!</em></p>
    <h3 class="dropspot">       Создание массивов</h3>
    <p class="dropspot">Мы показали, как проверить массив на наличие данных, но как создать массив для начала? Сначала его нужно <i>инициализировать</i>, прежде чем мы сможем его использовать, иначе <span data-keyref="GameMaker Name">GameMaker</span> выдаст нам ошибку. Инициализация массива означает, что мы присваиваем каждому слоту массива начальное значение, чтобы подготовить его к использованию в других местах кода проекта. Это важно помнить, так как это означает, что перед использованием массивов необходимо провести определенное планирование, но инициализировать массив достаточно просто, используя цикл повтора, как показано ниже:</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">Этот простой код инициализирует массив из десяти слотов (от 0 до 9) для хранения 0, т.е. каждый слот в массиве содержит значение 0. Вы заметите, что массив был инициализирован в <i>обратном</i> порядке, причем последнее значение было определено первым. Это не является строго необходимым, но это оптимальный способ, так как он резервирует место в памяти, которое точно соответствует размеру массива, в то время как если вы инициализируете массив от 0 <em>вверх</em>, память должна быть выделена заново для каждого дополнительного значения (таким образом, для массива с десятью слотами инициализация в цикле изменит распределение памяти десять раз). Разница в скорости незначительна для небольших массивов, но большие массивы должны быть максимально оптимизированы таким образом.</p>
    <p class="note"><b>ПРИМЕЧАНИЕ</b>: Экспорт HTML5 является исключением из вышеуказанного правила, и при нацеливании на него следует инициализировать массивы в последовательном порядке от 0 вверх.</p>
    <p class="dropspot">Вы также можете использовать функцию <span class="notranslate">GML</span> <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> для инициализации массива с фиксированным размером, и вы даже можете создавать &quot;пустые&quot; массивы <em>без</em> значений, например:</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">Это сообщает <span class="notranslate">GameMaker</span>, что переменная &quot;<span class="inline">my_array</span>&quot; является массивом, и вы можете <a href="../GML_Reference/Variable_Functions/array_push.htm">добавлять</a> в нее <a href="../GML_Reference/Variable_Functions/array_push.htm">значения</a> в любое время в будущем. Однако если вы попытаетесь получить доступ к значению в пустом массиве, то получите ошибку.<br></p>
    <p class="dropspot">Если вы уже знаете, какие элементы вы хотите поместить в массив, вы можете добавить значения, разделенные запятыми, между скобками при объявлении массива:</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       Границы массива</h3>
    <p class="dropspot">Вы всегда должны следить за тем, чтобы обращаться только к действительным позициям массива, так как попытка получить доступ к значению вне массива также приведет к ошибке. Например, это приведет к аварийному завершению проекта при запуске:</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">Массив был инициализирован только с 5 позициями, но мы пытались получить позицию 7 - поскольку массивы нумеруются от 0, <span class="inline">array[6]</span> является позицией 7 - поэтому игра выдает ошибку и терпит крах.</p>
    <h3 class="dropspot">       Использование массивов</h3>
    <p class="dropspot">Как же практически использовать массив? Точно так же, как мы используем обычную переменную, как показано в следующих примерах:</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if (array[9] == 10)<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">Поскольку массивы нумеруются последовательно, это означает, что вы можете просмотреть их в цикле, чтобы выполнить дополнительные действия, точно так же, как мы это сделали для инициализации:</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          _total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), _total);
    </p>
    <p class="dropspot">Приведенный выше код сложит все значения в нашем массиве, отрисует каждое из них и в конце выведет общее значение.</p>
    <h3 class="dropspot">       Удаление массивов</h3>
    <p class="dropspot">Последнее, что следует упомянуть о массивах, это то, что вы можете удалить массив, просто &quot;переназначив&quot; переменную, определяющую его, на одно значение. Это освободит память, связанную со всеми позициями и значениями для этого массива. Например:</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = undefined;
    </p>
    <p class="dropspot">Если массив имеет несколько измерений (см. ниже), все они также будут очищены. Обратите внимание, что при создании массивов в экземплярах их не нужно очищать при удалении экземпляра из игры, поскольку они будут автоматически удалены <a class="glossterm" data-glossterm="сборщик мусора" href="#">сборщиком мусора</a> при уничтожении или завершении комнаты. Однако если какие-либо позиции массива содержат ссылки на <em>динамические</em> активы, такие как системы частиц, буферы или структуры данных, то их <em>необходимо</em> уничтожить перед удалением массива, уничтожением экземпляра или завершением комнаты.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Многомерные массивы</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">Мы знаем, что такое одномерный массив, но в <span data-keyref="GameMaker Name">GameMaker</span> вы можете иметь массивы с несколькими измерениями, которые, по сути, структурированы как массив внутри массива внутри массива... Например, следующий массив является <strong>двумерным</strong> (двухмерным):</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">Это, по сути, говорит <span class="notranslate">GameMaker</span>, что массив на самом деле состоит из различных одномерных массивов. Вот расширенный пример:</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">В приведенном выше коде <span class="inline">array[0]</span> содержит другой массив, как и <span class="inline">array[1]</span>.</p>
    <p class="dropspot">Многомерный массив должен быть инициализирован перед использованием, как и одиночный одномерный массив, и может содержать вещественные числа, строки и любые другие <a href="Data_Types.htm">типы данных</a>, как и любая переменная, что делает их идеальными кандидатами для любой игры, в которой необходимо хранить большие объемы данных в легкодоступном виде (помните, что вы можете легко циклически просматривать массив).</p>
    <p class="dropspot">Вы также можете инициализировать многомерный массив в одном операторе путем вложения одномерных массивов:</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">Многомерные массивы также не ограничиваются <em>только </em>двумя измерениями, и вы можете иметь 3, 4 или более измерений массива, как это требуется в вашем коде, просто добавив <span class="inline">[n]</span> дополнительные аргументы, например:</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">Следует также отметить, что длина каждого измерения в массиве может быть разной, поэтому вы можете иметь начальное измерение массива длиной 3, но второй элемент измерения может быть разной длины для каждого слота в первом измерении; например:</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">В приведенном выше коде <span class="inline">array[0]</span> имеет 2 слота, <span class="inline">array[1]</span> - 4 слота и <span class="inline">array[2]</span> - 3 слота.</p>
    <h3 class="dropspot">       Расширенный пример</h3>
    <p class="dropspot">Вот последний пример того, как это может быть использовано в реальной игре: Допустим, вы хотите породить четырех разных врагов в четырех разных точках вашей игры в зависимости от случайного значения. Для этого мы можем использовать массив с двумя измерениями и не писать много кода.</p>
    <p class="dropspot">Сначала нам следует инициализировать массив, который мы будем использовать в событии Create нашего объекта &quot;controller&quot; (обратите внимание на использование комментариев, чтобы напомнить вам, что делает каждый элемент массива):</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">Теперь у нас есть объекты для порождения экземпляров и соответствующие им координаты порождения x и y в комнате, сохраненные в нашем массиве. Теперь это можно использовать следующим образом в другом событии объекта контроллера (например, сигнал тревоги или событие нажатия клавиши):</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">Этот короткий код теперь будет порождать случайного врага в игровой комнате, и он использует гораздо меньше кода, чем структура &quot;<span class="inline">if / then / else</span>&quot; или даже &quot;<span class="inline">switch</span>&quot;, а поскольку массив инициализируется в событии create, то редактировать и изменять любые из этих значений гораздо проще, поскольку они не <a class="glossterm" data-glossterm="с жестким кодом" href="#">закодированы</a> в остальном коде проекта.</p>
  </div>
  <p> </p>
  <h2>Массивы как аргументы функций</h2>
  <p>Вы можете передавать массивы в <a href="Script_Functions.htm">функции сценария</a> и <a href="Method_Variables.htm">переменные метода</a> в качестве аргументов и изменять эти массивы в любом месте внутри функции. При этом будут изменены и исходные массивы.</p>
  <p>Например, эта функция просто изменяет первые три элемента переданного в нее массива:</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>Теперь вы можете создать массив и передать его в эту функцию, которая изменит массив:</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>В предыдущих версиях <span class="notranslate">GameMaker</span> это было не так, поскольку при изменении массива внутри функции создавалась копия. При желании это <em>устаревшее</em> поведение можно включить: для получения дополнительной информации читайте раздел &quot;<strong>Копирование при записи</strong>&quot; ниже.</p>
  <h2 id="h">Копирование на запись</h2>
  <p>Поведение &quot;Копировать при записи&quot; устарело и используется только в том случае, если в <a href="../../Settings/Game_Options.htm">общих параметрах игры</a> включена опция &quot;<strong>Включить поведение &quot;Копировать при записи&quot; для массивов</strong>&quot;. В этом разделе описывается поведение массивов при включении этой опции.</p>
  <p>Как было описано в предыдущем разделе, массивы можно передавать в функции в качестве аргументов. Для этого нужно просто указать переменную массива (не нужно указывать каждую из отдельных позиций, а также скобки <span class="inline">[]</span> ), и весь массив будет <b>передан</b> в функцию <b>по ссылке</b>:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>Однако, когда функция <strong>Copy on Write</strong> включена, изменение любого значения массива внутри функции создает временную копию с вашими изменениями. Исходный массив не изменяется. Такое поведение называется Copy on Write.</p>
  <p>Чтобы действительно изменить исходный массив, который был передан в функцию, вы должны либо вернуть его обратно, либо использовать аксессор <span class="inline">@</span>.</p>
  <p>Например, вызванная выше функция, <span class="inline2">do_something()</span>, может делать что-то простое вроде этого:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>Теперь вы ожидаете, что <span class="inline2">my_array</span> будет содержать значения <span class="inline2">1, 200, 4</span> и т.д., что обычно правильно - но когда включена функция <strong>Copy on Write</strong>, исходный массив остается незатронутым.</p>
  <p>Чтобы обойти эту проблему, можно сделать так, чтобы функция <strong>возвращала</strong> измененную копию массива, а затем применяла ее обратно к исходной переменной:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>Сама функция будет возвращать измененный массив обратно:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">ПРИМЕЧАНИЕ</span><b> </b>Приведенный выше код не нужен, если вы не изменяете значения массива, а только ссылаетесь на них. При ссылке на массив он не копируется и разбирается быстрее.</p>
  <p>Второе решение - использовать аксессор <span class="inline">@</span> для изменения значений массива напрямую, что экономит затраты процессора на создание временной копии. Это означает, что вам не нужно возвращать массив из функции и вы можете редактировать его напрямую:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>Использование этого аксессора обходит поведение Copy on Write и напрямую изменяет массив, на который ссылается. Это можно использовать для выборочного отключения Copy on Write для определенных операторов, сохраняя опцию включенной.</p>
  <p>Опять же, все это не нужно, если функция <strong>Copy on Write</strong> <strong>отключена</strong> (что является стандартным и рекомендуемым вариантом).</p>
  <p>Более подробную информацию об аксессорах и их работе, а также пример для массивов можно найти на следующей странице:</p>
  <ul class="colour">
    <li><a href="Accessors.htm">Аксессоры</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="GML_Overview.htm">Обзор GML</a></div>
        <div style="float:right">Следующее: <a data-xref="{title}" href="Structs.htm">Структуры и конструкторы</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>