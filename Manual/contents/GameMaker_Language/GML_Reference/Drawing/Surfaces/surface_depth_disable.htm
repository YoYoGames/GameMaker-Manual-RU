<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<<<<<<< HEAD
  <title>глубина_поверхности_запрещена</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
=======
  <title>surface_depth_disable</title>
  <meta name="generator" content="Adobe RoboHelp 2022" />
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <script src="../../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference for surface_depth_disable" />
  <meta name="rh-index-keywords" content="surface_depth_disable" />
  <meta name="search-keywords" content="surface_depth_disable" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
<<<<<<< HEAD
  <h1>глубина_поверхности_запрещена</h1>
  <p>Эта функция отключает автоматическое создание буфера глубины для <i>всех</i> поверхностей, которые создаются после ее отключения. Обычно все поверхности имеют буферы глубины, поэтому если вы рисуете 3D объекты на них, то они будут правильно отсортированы по глубине, чтобы
    для поддержания функционального паритета между рендерингом на поверхности и рендерингом в обратный буфер, однако выделение буферов глубины, по сути, удваивает объем памяти, требуемый для поверхностей, что может быть чрезмерным и ненужным накладным расходом.
    особенно если ваша игра очень требовательна к памяти, а для 2D игр они обычно не нужны.</p>
  <p>Чтобы использовать эту функцию, нужно вызвать ее <i>перед</i> созданием поверхности, а затем снова включить ее после (если потребуется). Все поверхности, созданные при отключенном буфере глубины, больше не будут использовать буфер глубины при отрисовке, что приводит к тому.
    что приводит к тому, что объекты, нарисованные на поверхности, имеют паритет глубины. Изображения ниже иллюстрируют это на практике:</p>
  <p><img>На изображении выше мы рисуем прямоугольник и треугольник, используя буфер вершин в 3D. Координаты
    координаты для красного треугольника располагают его позади зеленого прямоугольника, но код для рисования треугольника вызывается <i>после</i> кода для прямоугольника, и когда включен буфер глубины, треугольник все равно рисуется позади прямоугольника.
    поскольку соблюдается 3D-глубина. Однако когда мы отключаем буфер глубины для поверхности, соблюдается только порядок кода, поэтому треугольник рисуется поверх прямоугольника.</p>
  <p class="note"><b>ПРИМЕЧАНИЕ</b>: Чтобы правильно сохранять глубину в 3D при использовании поверхностей, необходимо не только включить буфер глубины, но и включить z-запись и z-тестирование. См. функции <a href="../GPU_Control/gpu_get_ztestenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_ztestenable()</span></a>    и <a href="../GPU_Control/gpu_get_zwriteenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_zwriteenable()</span></a> для получения дополнительной информации.</p>
  <p class="note"><b>ПРИМЕЧАНИЕ</b>: Если ваша игра на 100% 2D или вы знаете, что вам не нужен буфер глубины поверхности, то вполне достаточно вызвать эту функцию один раз в начале игры, чтобы отключить буфер.</p>
  <p> </p>
  <h4>Синтаксис:</h4>
  <p class="code">surface_depth_disable(disable);</p>
  <table>
    <tbody>
      <tr>
        <th>Аргумент</th><th>Тип</th>
        <th>Описание</th>
     </tr>
      <tr>
        <td><span class="notranslate">disable</span></td><td><span data-keyref="Type_Bool"></span></td>
        <td><span class="notranslate">If set to <span class="inline">true</span> буфер глубины будет отключен для созданных поверхностей.</td>
     </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Возвращается:</h4>
  <p class="code"><span data-keyref="Type_Void"></span></p>
  <p> </p>
  <h4>Пример:</h4>
  <p class="code">var _depth_setting = surface_get_depth_disable();<br/> surface_depth_disable(false);
    <br/> surface_with_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(true);
    <br/> surface_without_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(_depth_setting);
  </p>
  <p>Приведенный выше код сохраняет текущую настройку буфера глубины в переменной, а затем создает две поверхности, одну с включенной буферизацией глубины, а другую без нее, после чего снова восстанавливает исходную настройку.</p>
  <p> </p>
  <p> </p>
  <p> </p>
=======
  <h1><span data-field="title" data-format="default">surface_depth_disable</span></h1>
  <p>This function disables the automatic depth buffer generation for <i>all</i> surfaces that are created after it has been disabled. Normally all surfaces have depth buffers so if you draw 3D objects to them then it&#39;ll sort them properly by depth in order to maintain functional parity between rendering to surfaces and rendering to the back buffer, however allocating depth buffers essentially doubles the amount of memory required for surfaces, which could be an excessive and unnecessary overhead especially if your game is very memory intensive, and for 2D games they aren&#39;t generally required.</p>
  <p>To use this function you would call it <i>before</i> creating a surface, and then you can enable it again after (if required). All surfaces created when the depth buffer is disabled will no longer use a depth buffer when being drawn to, this results in the things being drawn to the surface having parity of depth. The images below illustrate this in practice:</p>
  <p><img alt="Surface depth buffer example" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Drawing/Surface_Depth_Buffer.png" />In the above image, we are drawing a rectangle and a triangle using a vertex buffer in 3D. The coordinates for the red triangle places it behind the green rectangle, but the code for drawing the triangle is called <i>after</i> the code for the rectangle, and when the depth buffer is enabled, the triangle is still drawn behind the rectangle as the 3D depth is being respected. However when we disable the depth buffer for the surface, only the code order is respected and so the triangle is drawn over the rectangle.</p>
  <p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"> </span> </b>To properly preserve depth in 3D when using surfaces, not only should you have the depth buffer enabled, but you should also have z-writing and z-testing enabled. See the functions <span class="inline3_func"><a data-xref="{title}" href="../GPU_Control/gpu_set_ztestenable.htm">gpu_set_ztestenable</a></span> and <span class="inline3_func"><a data-xref="{title}" href="../GPU_Control/gpu_set_zwriteenable.htm">gpu_set_zwriteenable</a></span> for more information.</p>
  <p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"> </span> </b>If your game is 100% 2D or you know that you don&#39;t need a surface depth buffer, then it should be fine to simply call this function once at the start of the game to disable the buffer.</p>
  <p> </p>
  <h4>Syntax:</h4>
  <p class="code"><span data-field="title" data-format="default">surface_depth_disable</span>(disable);</p>
  <table>
    <tbody>
      <tr>
        <th>Argument</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>disable</td>
        <td><span data-keyref="Type_Bool"><a href="../../../../../GameMaker_Language/GML_Overview/Data_Types.htm" target="_blank">Boolean</a></span></td>
        <td>If set to <span class="inline">true</span> the depth buffer will be disabled for created surfaces.</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Returns:</h4>
  <p class="code"><span data-keyref="Type_Void">N/A</span></p>
  <p> </p>
  <h4>Example:</h4>
  <p class="code">var _depth_setting = surface_get_depth_disable();<br />
    surface_depth_disable(false);<br />
    surface_with_depth = surface_create(room_width, room_height);<br />
    surface_depth_disable(true);<br />
    surface_without_depth = surface_create(room_width, room_height);<br />
    surface_depth_disable(_depth_setting);</p>
  <p>The above code stores the current depth buffer setting in a variable and then creates two surfaces, one with depth buffering enabled and one without, before restoring the original setting again.</p>
  <p> </p>
  <p> </p>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Surfaces.htm">Поверхности</a></div>
        <div style="float:right">Следующий: <a href="surface_get_height.htm"><span class="notranslate">surface_get_height</span></a></div>
      </div>
    </div>
<<<<<<< HEAD
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
=======
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2023 All Rights Reserved</span></h5>
>>>>>>> e8f331b1b74476a144e051c0d836bf120b342735
  </div>
  <!-- KEYWORDS
surface_depth_disable
-->
  <!-- TAGS
surface_depth_disable
-->
</body>
</html>