<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <title>Система отката</title>
  <meta name="topic-status" content="Draft" />
  <link rel="stylesheet" type="text/css" href="../../../assets/css/default.css" />
  <script src="../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Details for Rollback Multiplayer" />
  <meta name="template" content="../../../assets/masterpages/Manual_Page.htt" />
  <meta name="condition-tags" content="Export:Beta" />
</head>
<body>
  <h1>Система отката</h1>
  <p>После изучения руководства по <a data-xref="{title}" href="Creating_Multiplayer.htm">созданию многопользовательской игры</a> у вас могут возникнуть вопросы о том, как работает система отката. Эта страница призвана рассказать об этом подробнее.</p>
  <h2>Что такое откат?</h2>
  <p>При игре в Интернете легко столкнуться с задержкой. Если вы играете с кем-то удаленно, вам может потребоваться доля секунды, чтобы его данные дошли до вас, но даже этого может быть достаточно, чтобы испортить впечатление от игры.</p>
  <p>Rollback использует предсказания для уменьшения эффекта запаздывания. Основываясь на предыдущих вводах, он предсказывает, что другой пользователь собирается делать дальше, и мгновенно показывает вам результат этого предсказания.</p>
  <p>Когда прогноз верен, вы не испытываете задержек, и ваша игра становится намного более отзывчивой.</p>
  <p>Однако иногда система понимает, что ее прогноз был неверным. В этом случае она <em>откатывается</em> к последнему правильному состоянию и продолжает игру с этого момента. Именно поэтому игра называется &quot;<strong>многопользовательский откат</strong>&quot;.</p>
  <h3>Детерминизм</h3>
  <p>Откат является детерминированным. Он делится входными данными только с другими игроками и ожидает, что все они выполнят одну и ту же логику на заданных входных данных, выдавая одинаковые результаты на всех клиентах.</p>
  <p>Другой подход к многопользовательской игре - это &quot;репликация состояния&quot;, которая постоянно синхронизирует состояние игры между клиентами, гарантируя, что они всегда делают одно и то же.</p>
  <p>Rollback не делает этого - он только посылает входные данные, но также следит за состоянием, чтобы его можно было откатить в случае неверного предсказания.</p>
  <p class="note"><em><strong>Что такое клиент?</strong></em><br>
    <br>
    Клиент&quot; - это игрок в вашей игре, под которым понимается его копия игры, запущенная на его машине.
  </p>
  <h2>Как это работает?</h2>
  <p>Как уже говорилось ранее, Rollback <strong>передает входные данные только</strong> между игроками.</p>
  <p>Есть две основные вещи, которые обрабатывает Rollback:</p>
  <ul class="colour">
    <li><strong>Вход</strong>: <a href="Rollback_Functions/rollback_define_input.htm">Входы</a> каждого игрока передаются другим игрокам. Если игрок 0 нажимает <strong>&quot;fire&quot;</strong> в своем клиенте, Rollback гарантирует, что другие клиенты также увидят, что игрок 0 нажал <strong>&quot;fire&quot;</strong>.<br>
      <br>
     <strong>Предсказания выполняются только на входе.</strong>
    </li>
    <li><strong>Состояние</strong>: Сюда входят все управляемые объекты и их переменные. Они НЕ синхронизируются между игроками: изменение одной переменной в одном клиенте не приведет к ее автоматическому обновлению в другом клиенте.<br>
      <br>
     <strong>Состояние управляется только для того, чтобы его можно было откатить.</strong>
    </li>
  </ul>
  <h2>Итак... в чем разница?</h2>
  <p><strong>Ввод</strong> изменяет <strong>состояние</strong>, что является базовой концепцией мультиплеера Rollback.</p>
  <p>Вот пример:</p>
  <ul class="colour">
    <li><strong>Вход</strong>: Игрок 0 нажимает кнопку <strong>&quot;огонь&quot;</strong>.</li>
    <li><strong>Состояние</strong>: Поскольку Игрок 0 нажал кнопку "огонь", создается снаряд. Этот снаряд в конечном итоге сталкивается с камнем. В результате игрок 0 получает очко.<br>
      <br>
      По сути, это и есть вся ваша игра, полностью зависящая от ввода.
    </li>
  </ul>
  <p>&quot;<strong>Вход</strong>&quot; - это то, что Rollback передает между всеми игроками, а не состояние.</p>
  <p>Однако, поскольку все игровые клиенты выполняют одну и ту же логику на полученном входе (что является обязательным требованием), <strong>все они приводят к одному и тому же состоянию</strong>.</p>
  <p><img class="center" height="521" src="../../../assets/Images/Scripting_Reference/GML/Reference/Rollback/multiplayer_input_sync_explained.png" width="1096" /></p>
  <h2>Что же такое государство?</h2>
  <p>Если синхронизируется только вход, то для чего нужно <strong>состояние</strong>?</p>
  <p>Поскольку вход влияет на состояние, неправильное предсказание входа может привести к <strong>неправильному состоянию</strong>.</p>
  <p>Когда откат обнаруживает, что предсказание было ошибочным, он заменяет текущее состояние на правильное и снова выполняет вводы и предсказания с этого момента. Это включает все ваши управляемые объекты и их переменные.</p>
  <p>Это не означает, что Rollback синхронизирует объекты и переменные между клиентами. Если <span class="inline2">переменная_a</span> имеет значение <span class="inline2">&quot;Gurpreet&quot;</span> в одном клиенте, это не значит, что другие клиенты увидят то же значение.</p>
  <p>Они будут видеть одно и то же значение переменной только в том случае, если оно получено от ввода данных игроком или какой-либо другой управляемой системы, например, будильников или случайных функций.</p>
  <h2 id="h2">Управляемые объекты</h2>
  <p>Объекты имеют флажок &quot;<strong>Managed</strong>&quot;, который по умолчанию установлен для новых объектов:</p>
  <p><img>Объекты, помеченные как управляемые, имеют возможность отката и выполнения предсказаний, включая все их переменные, создание и уничтожение.</p>
  <p>Все объекты, которые являются частью игрового процесса, такие как игрок, объекты менеджера/контроллера, подборщики предметов, снаряды и т.д., должны быть помечены как управляемые.</p>
  <p>Вы можете отключить эту функцию для объектов, которые не нуждаются в синхронизации между игроками, например, статические объекты мира, визуальные эффекты, эффекты и т.д., которые никак не влияют на игровой процесс.</p>
  <p>Обратите внимание, что управляемое свойство родительского объекта не применяется к его дочерним объектам автоматически, поэтому для каждого дочернего объекта необходимо установить управляемый флажок вручную.</p>
  <h2 id="h">Тест синхронизации</h2>
  <p><span class="inline"><a href="Rollback_Functions/rollback_create_game.htm">rollback_create_game()</a></span> принимает аргумент для Sync Test, который включен по умолчанию (когда аргумент не указан).</p>
  <p>Sync Test используется для тестирования вашей игры в автономном режиме. Если возникнут проблемы с синхронизацией, он сообщит вам об этом, напечатав ошибку в журнале Output Log. Вы можете использовать Sync Test на <span class="notranslate">Windows</span>, macOS и Opera GX.</p>
  <p>Sync Test выполняет весь код вашей игры дважды в кадре, чтобы проверить любые проблемы синхронизации. Это означает, что при тестировании в автономном режиме вы можете увидеть, что некоторые события происходят дважды, чего не произойдет при запуске игры в режиме онлайн.</p>
  <h3>Случайный и имитационный вход</h3>
  <p>Во время Sync Test &quot;удаленные&quot; экземпляры игроков получают случайные входные значения для своих <a href="Defining_Inputs.htm">определенных входов</a> в качестве простой формы тестирования. Вы можете отключить эту функцию с помощью <span class="inline"><a href="Rollback_Functions/rollback_use_random_input.htm">rollback_use_random_input()</a></span>.</p>
  <p><video class="center" src="../../../assets/Images/Scripting_Reference/GML/Reference/Rollback/rollback_two_players_synctest.mp4" width="856" height="420" controls="" align="center"></video></p>
  <p class="video_subtitle">Второй игрок получает случайный ввод во время Sync Test.</p>
  <p>Вы также можете назначить временный имитационный вход для удаленных проигрывателей в режиме Sync Test. Подробности см. в разделе <a data-xref="{text}" href="Defining_Inputs.htm#h1">Макетный ввод</a>.</p>
  <h2>Эффективная разработка многопользовательской игры</h2>
  <p>Вы должны убедиться, что все игровые клиенты выполняют одну и ту <strong>же логику</strong> при получении одинаковых <strong>входных данных</strong>. Если конкретный экземпляр был создан или перемещен только для одного клиента, это не будет отражено на других клиентах.</p>
  <p>Эта проблема обычно не возникает, если вы программируете свою игру, как показано в разделе " <a data-xref="{title}" href="Creating_Multiplayer.htm">Создание многопользовательской игры</a>", когда вся логика игрока выполняется одинаково для всех экземпляров игрока, независимо от того, является ли экземпляр <a href="Rollback_Variables/player_local.htm">локальным или нет</a>. Однако если вы реализуете условие, чтобы сделать что-то только для определенного игрока, но не для других, это приведет к нарушению состояния игры.</p>
  <h2 id="h1">Определение объекта игрока</h2>
  <h3>Автоматическое создание экземпляров игроков</h3>
  <p>Как показано в разделе <a data-xref="{title}" href="Creating_Multiplayer.htm">Создание многопользовательской игры</a>, вы можете определить объект игрока с помощью <span class="inline"><a href="Rollback_Functions/rollback_define_player.htm">rollback_define_player()</a></span> / <a data-xref="{title}" href="../../../Drag_And_Drop/Drag_And_Drop_Reference/Rollback/Define_Player.htm">Define Player (Rollback)</a>, и система автоматически создаст его экземпляры для каждого подключенного игрока. Она также будет уничтожать экземпляры для игроков, которые отсоединяются.</p>
  <p>Созданные таким образом экземпляры игроков получают свои идентификаторы автоматически, в переменной <span class="inline"><a data-xref="{title}" href="Rollback_Variables/player_id.htm">player_id</a></span>. Внутри каждого экземпляра игрока вы можете просто вызвать <a href="Rollback_Functions/rollback_get_input.htm"><span class="inline">rollback_get_input()</span></a> без каких-либо аргументов, и это даст вам входные данные для этого конкретного игрока.</p>
  <p>Это стандартный способ использования системы отката, однако вы также можете управлять экземплярами игроков и их входами вручную.</p>
  <h3>Ручное создание экземпляров игроков</h3>
  <p>Чтобы управлять экземплярами игроков вручную, не вызывайте <span class="inline"><a href="Rollback_Functions/rollback_define_player.htm">rollback_define_player()</a></span>. Это приведет к тому, что игра начнется без создания каких-либо экземпляров игроков.</p>
  <p>Затем создайте собственные экземпляры игроков вручную, в идеале в событии <a data-xref="{text}" href="Rollback_Events.htm#h">Rollback Start</a>, и присвойте им идентификаторы игроков в пользовательской переменной. Чтобы получить ввод для игрока, вызовите <a href="Rollback_Functions/rollback_get_input.htm"><span class="inline">rollback_get_input()</span></a> и укажите ID игрока в качестве аргумента. Вызовите <a href="Rollback_Functions/rollback_get_info.htm"><span class="inline">rollback_get_info()</span></a> чтобы получить те <a href="Rollback_Variables/Rollback_Variables.htm">переменные</a> в структуре, которые в противном случае были бы присвоены игрокам автоматически.</p>
  <p>Таким образом, вы можете вручную управлять тем, когда и как создаются экземпляры игроков, присваивать им идентификаторы и получать данные для конкретного игрока.</p>
  <h3>Поддерживайте инстансы игроков</h3>
  <p>Если вы используете <span class="inline"><a href="Rollback_Functions/rollback_define_player.htm">rollback_define_player()</a></span> / <a data-xref="{title}" href="../../../Drag_And_Drop/Drag_And_Drop_Reference/Rollback/Define_Player.htm">Define Player (Rollback)</a>, не уничтожайте созданные экземпляры игроков. Если вам нужно показать игрока побежденным, то измените его <span class="notranslate">sprite</span>, или скройте его с помощью другого метода, но сохраните экземпляр живым, так как он управляется <span class="notranslate">GameMaker</span>.</p>
  <h2>Одиночный игрок</h2>
  <p>Систему Rollback можно использовать при создании однопользовательской игры. Просто укажите <strong>1</strong> в качестве количества игроков при вызове <span class="inline"><a href="Rollback_Functions/rollback_create_game.htm">rollback_create_game()</a></span>.</p>
  <p>Таким образом, система никогда не будет подключаться к каким-либо серверам, и ваша игра будет по сути автономной, с возможностью расширения до многопользовательской онлайн-игры, когда вы захотите.</p>
  <p>Используйте этот подход, когда вы создаете новый проект, в котором в будущем может использоваться многопользовательская игра, поскольку будет сложнее внедрить многопользовательскую игру в уже завершенную игру без использования системы отката.</p>
  <h2 id="h4">Ручной и автоматический запуск</h2>
  <p>По умолчанию многопользовательская игра начинается, как только все игроки присоединятся к ней. Однако вы можете начать ее до этого момента, вызвав команду <a href="Rollback_Functions/rollback_start_game.htm"><span class="inline">rollback_start_game()</span></a>.</p>
  <p>Вы можете полностью отключить поведение автозапуска, вызвав команду <a href="Rollback_Functions/rollback_use_manual_start.htm"><span class="inline">rollback_use_manual_start()</span></a>. Это означает, что игра будет ждать, пока вы запустите ее вручную.</p>
  <p>Автозапуск автоматически отключается при <a href="Rollback_Functions/rollback_use_player_prefs.htm">включенных</a> настройках игрока.</p>
  <p><span></span></p>
  <h2>Дальнейшее чтение</h2>
  <p>Более подробную информацию о системе Rollback читайте на следующих страницах:</p>
  <ul class="colour">
    <li><a data-xref="{title}" href="Defining_Inputs.htm">Определение входов</a></li>
    <li><a data-xref="{title}" href="Rollback_Constraints.htm">Ограничения отката</a></li>
    <li><a data-xref="{title}" href="Rollback_Events.htm">События отката</a></li>
    <li><a data-xref="{title}" href="Rollback_Preferences.htm">Предпочтения игрока</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div>Назад: <a data-xref="{title}" href="Rollback_Multiplayer.htm">Rollback Multiplayer</a></div>
        <div>Следующее: <a data-xref="{title}" href="Defining_Inputs.htm">Определение входов</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
</body>
</html>