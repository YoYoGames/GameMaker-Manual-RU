<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Рисование</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code to show people how things are drawn." />
  <meta name="rh-index-keywords" content="Quick Start - Drawing" />
  <meta name="search-keywords" content="drawing,draw event,GUI layer" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Рисование</h1>
  <p>Цель этого раздела (и следующего раздела " <a href="Movement_And_Controls.htm">Движение и управление</a>") - дать вам практические примеры <span class="notranslate">GML</span> или <span class="notranslate">GML</span> Visual, чтобы вы могли как можно быстрее приступить к созданию своих первых игровых проектов. Мы не будем объяснять все слишком подробно, поскольку хотим, чтобы вы как можно быстрее приступили к созданию игры, поэтому мы рекомендуем вам изучить все ссылки по ходу дела и использовать функцию &quot;поиск&quot; в руководстве для поиска дополнительной информации о том, в чем вы не уверены.</p>
  <p>В этом разделе мы сосредоточимся на простом рисовании информации на экране, как в виде текста, так и в виде изображений, а также расскажем немного больше о различных <strong>событиях Draw</strong>, в частности, об основном событии <strong>Draw</strong> и событии <strong>Draw GUI </strong>(обратите внимание, что в некоторых примерах вам потребуется добавить другие события, но мы будем объяснять их по мере того, как мы до них дойдем).</p>
  <p><img alt="The Draw Events" class="center" src="../assets/Images/QS_Guide/QS_DrawEvents.png" /></p>
  <p>Прежде чем двигаться дальше, вы можете создать новый проект (либо <span class="notranslate">GML</span>, либо <span class="notranslate">GML</span> Visual) на <a href="../Introduction/The_Start_Page.htm">Стартовой странице</a> и добавить (или создать) несколько <span class="notranslate">sprites</span>, а также объект или два, поскольку мы дадим вам некоторый код, который вы сможете протестировать с их помощью. В качестве <span class="notranslate">sprite</span> для нашего объекта подойдет даже белый квадрат!</p>
  <p>Как уже упоминалось в разделе " <a href="Objects_And_Instances.htm">Объекты и экземпляры</a>", если вы не добавите к объекту событие Draw Event, то <span data-keyref="GameMaker Name">GameMaker</span> будет рисовать по умолчанию, то есть, если объекту назначен <span class="notranslate">sprite</span>, то этот <span class="notranslate">sprite</span> будет нарисован, вместе с любыми добавленными трансформациями. Что мы подразумеваем под трансформациями? Ну, каждый объект имеет ряд встроенных <a class="glossterm" data-glossterm="переменная" href="#">переменных</a>, которые управляют тем, как экземпляр объекта рисует свой <span class="notranslate">sprite</span> при рисовании по умолчанию, и вы можете изменять эти переменные по ходу игры, чтобы изменить способ рисования <span class="notranslate">sprite</span>.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Список всех встроенных переменных, которые можно использовать для преобразования экземпляра <span class="notranslate">sprites</span>, можно найти <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">здесь</a>. <span class="notranslate">GML</span> У визуальных пользователей есть несколько специальных действий, влияющих на эти переменные, которые вы можете найти <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">здесь</a>, а также вы можете использовать сами переменные вместе с действиями <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Get_Instance_Variable.htm">Get Instance Variable</a> и <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Set_Instance_Variable.htm">Set Instance Variable</a>.</p>
  <p>Давайте рассмотрим несколько примеров:</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Изменение альфа (прозрачности)</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot"> <strong>Альфа-значение </strong>- это то, что контролирует прозрачность рисуемого объекта, и в <span data-keyref="GameMaker Name">GameMaker</span> вы можете использовать встроенную переменную <span class="inline">image_alpha</span>, чтобы изменить прозрачность назначенного объекта <span class="notranslate">sprite</span>. Чтобы увидеть, как это работает, откройте (или создайте) объект, присвойте ему <span class="notranslate">sprite</span>, а затем создайте <strong>событие Create Event</strong>. В событии Create Event просто добавьте следующий <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png" /></p>
    <p class="code">var _val = random(1);
      <br />
      image_alpha = _val;
    </p>
    <p class="dropspot">Альфа изображения рассчитывается как значение от 0 до 1, где 0 - полностью прозрачное, а 1 - полностью непрозрачное (по умолчанию установлено значение 1). Поэтому в данном примере мы просто устанавливаем альфа-фактор изображения на случайное десятичное значение от 0 до 1. Разместите несколько экземпляров этого объекта в комнате, а затем нажмите кнопку <strong>Play </strong> <img> в верхней части сайта <span class="notranslate">IDE</span>.</p>
    <p class="dropspot">Вы должны увидеть, что каждый экземпляр объекта рисует свой <span class="notranslate">sprite</span> с разной прозрачностью, например:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Изменение цветовой гаммы (тонирование)</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot">Когда ваш объект по умолчанию рисует <span class="notranslate">sprite</span>, этот <span class="notranslate">sprite</span> фактически рисуется <strong>смешанным </strong>(или <strong>тонированным</strong>) цветом, и значение этого цвета хранится во встроенной переменной <span class="inline">image_blend</span>. По умолчанию этот цвет белый, что означает, что при отображении на экране цвет не будет добавлен к <span class="notranslate">sprite</span>. Однако вы можете использовать другие цвета для достижения специальных эффектов, например, использовать красный цвет, чтобы показать, что экземпляр получил некоторые повреждения.</p>
    <p class="dropspot">В этом примере мы собираемся смешивать различные цвета с <span class="notranslate">sprite</span> во время нажатия и удержания клавиши, поэтому вам нужно открыть (или создать) объект, присвоить ему <span class="notranslate">sprite</span>, а затем дать объекту <strong>событие Key Down &lt;Space&gt;</strong>.</p>
    <p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png" /></p>
    <p class="dropspot">В этом событии Key Down Event добавьте следующий <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);
      <br />
      image_blend = _col;
    </p>
    <p class="dropspot">Разместите несколько экземпляров этого объекта в комнате, а затем нажмите кнопку Play <img> в верхней части сайта <span class="notranslate">IDE</span> и протестируйте нажатие и отпускание клавиши <em>Space </em>. Вы должны увидеть, что каждый экземпляр будет быстро менять свой цвет, пока клавиша удерживается, и перестанет меняться, когда клавиша будет отпущена:</p>
    <p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Изменение масштаба</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Еще одним свойством, которое мы можем изменить для нашего <span class="notranslate">sprite</span>, является <strong>масштаб </strong>, позволяющий нам рисовать его больше или меньше, когда мы захотим. Масштаб определяется независимо по осям X и Y двумя отдельными переменными: <span class="inline">image_xscale</span> и <span class="inline">image_yscale</span>. По умолчанию они установлены в 1, и действуют как <strong>множители</strong>, так что значение 0,5 будет половиной масштаба, а значение 2 - удвоением масштаба.</p>
    <p class="note"><strong>ВАЖНО! </strong>Изменение назначенного масштаба <span class="notranslate">sprite</span> с помощью этих переменных <strong>также изменит размер ограничивающей</strong> рамки, что означает, что область обнаружения столкновений для <span class="notranslate">sprite</span> также изменится.</p>
    <p class="dropspot">В этом примере мы будем использовать простую математику, чтобы заставить экземпляр масштабировать <span class="notranslate">sprite</span> вверх и вниз в цикле. Для начала откройте (или создайте) объект, присвойте ему <span class="notranslate">sprite</span>, а затем дайте объекту <strong>событие Create Event</strong>. В этом событии добавьте следующее:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">timer = 0;</p>
    <p class="dropspot">Теперь добавьте <strong>событие Step Event</strong> к объекту с помощью этого:</p>
    <p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png" /></p>
    <p class="code">timer = timer + 1;
      <br />
      var _val = dsin(timer);
      <br />
      image_xscale = 1 + _val;
      <br />
      image_yscale = 1 + _val;
    </p>
    <p class="dropspot">Здесь мы используем функцию maths <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a> для создания значения между -1 и 1 с помощью переменной timer, а затем применяем ее к переменным scale. После размещения нескольких экземпляров в комнате и нажатия кнопки <strong>Play </strong> <img> вы должны увидеть, как экземпляры масштабируются вверх и вниз от масштаба 0 до масштаба 2, а затем обратно.</p>
    <p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png" /></p>
    <p class="dropspot">И последнее... измените раздел &quot; <span class="inline">image_yscale</span>&quot; на &quot; <span class="inline">1 - _val</span>&quot; и посмотрите, что получится!</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Приведенные выше примеры иллюстрируют лишь некоторые из множества способов манипулирования объектом <span class="notranslate">sprite</span>, когда <span data-keyref="GameMaker Name">GameMaker</span> рисует по умолчанию, но как быть, если вы хотите нарисовать несколько объектов? В таких случаях вам необходимо использовать <strong>событие Draw Event</strong>, чтобы явно указать <span data-keyref="GameMaker Name">GameMaker</span>, что рисовать, что мы и сделаем в следующих примерах.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Рисование двух (или более) <span class="notranslate">Sprites</span> вместе</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">Для этого примера вам понадобятся два <span class="notranslate">sprites</span> и один объект. Назовите объекты <span class="notranslate">sprites</span> &quot; <span class="inline">spr_One</span>&quot; и &quot; <span class="inline">spr_Two</span>&quot;, затем установите начало координат объекта &quot; <span class="inline">spr_One</span>&quot; в центр, а для объекта &quot; <span class="inline">spr_Two</span>&quot; установите начало координат в левую среднюю часть:</p>
    <p class="dropspot"><img>Назначьте первый <span class="notranslate">sprite</span> (&quot; <span class="inline">spr_One</span>&quot; с центром начала координат) созданному вами объекту, а затем добавьте <strong>событие Create Event</strong>. В событии Create Event добавьте следующие <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png" /></p>
    <p class="code">draw_angle = 0;</p>
    <p class="dropspot">Мы собираемся использовать эту переменную для поворота &quot; <span class="inline">spr_Two</span>&quot; во времени и нарисовать его наложенным на <span class="notranslate">sprite</span>, присвоенный объекту (&quot; <span class="inline">spr_One</span>&quot;). Для этого нам нужно добавить к объекту <strong>событие Draw Event </strong>. Этим мы сообщаем <span data-keyref="GameMaker Name">GameMaker</span>, что хотим взять на себя управление тем, что рисует объект, что означает, что наш код будет включать вызов <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a> функция или <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>Нарисовать себя</strong></a> действие. Это действие просто повторяет действия объекта при отсутствии события Draw Event и по умолчанию рисует назначенный <span class="notranslate">sprite</span>. Затем мы нарисуем второй <span class="notranslate">sprite</span>, который мы хотим использовать в качестве вращающегося оверлея <span class="notranslate">sprite</span>. Визуальные <span class="notranslate">GML</span> и <span class="notranslate">GML</span> выглядят следующим образом:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = draw_angle + 0.5;
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Добавьте несколько экземпляров объекта в редактор комнаты, а затем нажмите кнопку <strong>Play </strong> <img> в верхней части <a class="glossterm" data-glossterm="IDE" href="#">IDE</a>. Если все прошло правильно, вы должны увидеть что-то вроде этого:</p>
    <p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling" /></p>
    <p class="dropspot">Прежде чем мы оставим этот пример, давайте немного подправим его, и вместо того, чтобы просто вращать &quot; <span class="inline">spr_Two</span>&quot;, мы сделаем так, чтобы он указывал на позицию мыши. Для этого нам нужно изменить событие Draw Event <span class="notranslate">GML</span> Visual или <span class="notranslate">GML</span>, чтобы оно выглядело следующим образом:</p>
    <p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = point_direction(x, y, mouse_x, mouse_y);
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Запустите проект снова, и на этот раз вы увидите нечто совсем другое!</p>
    <p class="dropspot"><img>Теперь <span class="notranslate">sprite</span> указывает на мышь независимо от того, куда вы ее переместили! Как видите, наслоение <span class="notranslate">sprites</span> - это отличный способ добавить детали к объекту или заставить что-то двигаться независимо от &quot;базового&quot; <span class="notranslate">sprite</span>, назначенного объекту, и это мощный инструмент, который вы, вероятно, будете часто использовать в своих собственных проектах.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#">Рисование вещей, отличных от спрайтов</a></p>
  <div class="droptext" data-targetname="drop_down4">
    <p class="dropspot">В событии Draw Event можно рисовать не только <span class="notranslate">sprites</span>, но и другие объекты, например текст или фигуры. В этом примере мы будем использовать визуальную функцию <span class="notranslate">GML</span> или <span class="notranslate">GML</span> <span class="inline">draw_self()</span> для рисования объекта <span class="notranslate">sprite</span>, но мы также нарисуем некоторые другие вещи, начиная с <strong>текста</strong>. Для этого примера вам понадобится <span class="notranslate">sprite</span> и объект (с назначенным ему <span class="notranslate">sprite</span> ). В объекте сначала добавьте <strong>событие Create Event</strong> с этим <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png" /></p>
    <p class="code">name = choose(&quot;Fred&quot;, &quot;Jonas&quot;, &quot;Sharon&quot;, &quot;Kate&quot;, &quot;Frank&quot;, &quot;John&quot;, &quot;Monica&quot;, &quot;Amanda&quot;);
      <br />
      number = irandom(100);
    </p>
    <p class="dropspot">Все, что это делает, это говорит <span data-keyref="GameMaker Name">GameMaker</span> выбрать одно из перечисленных имен и присвоить его переменной, а также сгенерировать случайное число от 0 до 100 для каждого экземпляра объекта. Мы хотим вывести эти значения на экран, поэтому для этого нужно добавить <strong>событие Draw Event</strong> и в него добавить следующее <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">В приведенном выше коде вы заметите, что мы используем <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a> функция или <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>Число в строку</strong></a> для переменной &quot;number&quot;, которую мы хотим нарисовать. Это связано с тем, что весь текст должен состоять из <em>символов</em>, а не из значений, и поэтому нам нужно использовать эту функцию/действие для преобразования значения числа в символы, которые мы хотим нарисовать. В данном случае мы берем сгенерированное нами случайное число и превращаем его в &quot;строку&quot; символов, которые можно нарисовать. Также обратите внимание, что мы установили <strong>выравнивание</strong> текста. Это просто указывает <span data-keyref="GameMaker Name">GameMaker</span>, где начать рисовать текст относительно заданной позиции, и в данном случае мы хотим, чтобы текст был выровнен по оси x.</p>
    <p class="dropspot">Добавьте несколько экземпляров объекта в редактор комнаты, а затем нажмите кнопку Play <img> в верхней части страницы <span class="notranslate">IDE</span>. Вы должны увидеть нечто подобное:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Во всех примерах до сих пор мы рисовали <span class="notranslate">sprite</span>, назначенный экземпляру, но это не всегда так. В событии draw можно нарисовать <strong>все, что угодно</strong>, независимо от назначенного <span class="notranslate">sprite</span>. Чтобы проиллюстрировать этот момент, мы изменим имеющийся код, удалив вызов <span class="inline">draw_self()</span> и заменив его функцией для рисования цветного эллипса, как показано ниже:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif" /></p>
    <p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Запустите проект снова, и вы должны увидеть следующее:</p>
    <p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png" /></p>
    <p class="dropspot">Важно отметить, что даже если мы не рисуем назначенный <span class="notranslate">sprite</span>, <strong>он все равно будет использоваться для обнаружения столкновений</strong>. Таким образом, пока вы рисуете что-то одно, столкновения все равно будут рассчитываться на основе назначенного <span class="notranslate">sprite</span>, как если бы он был размещен в комнате вместе с экземпляром, даже если он не виден. Это довольно удобно, так как позволяет рисовать разные <span class="notranslate">sprites</span>, но сохранять единую <strong>маску столкновений</strong> на основе назначенного <span class="notranslate">sprite</span>. Также обратите внимание, что вы все еще можете применять различные преобразования, такие как X/Y масштаб, и столкновения будут основываться на измененном размере, даже если ничего не будет нарисовано, чтобы показать это.</p>
  </div>
  <p> </p>
  <p> </p>
  <h1>Уровень графического интерфейса</h1>
  <p>В начале страницы мы упоминали, что будем говорить о <strong>событии Draw GUI Event</strong>, а также о событии Draw Event, поэтому давайте рассмотрим их сейчас. Событие Draw GUI Event работает с так называемым <strong> слоем <a class="glossterm" data-glossterm="GUI" href="#">GUI</a></strong> Layer, который представляет собой специальный слой рисунка фиксированной ширины и высоты, который рисуется поверх экземпляров в комнате. Слой GUI хорош тем, что <em> он не перемещается вместе с камерой комнаты</em>, поэтому это идеальное место для добавления статичных элементов GUI, таких как очки, шкалы здоровья и другая информация, которую ваша игра должна передать пользователю. Более подробную информацию о слое GUI можно найти в разделе " <a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">События рисо</a> вания" руководства.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Комнаты могут быть больше, чем размер экрана, поэтому вы можете иметь большие уровни, по которым игрок может перемещаться. Это означает, что в редакторе комнат (или в коде) вам нужно определить <strong>камеру </strong>, которая будет следовать за действием вашей игры. По сути, это способ настройки фиксированной области экрана для отображения различных частей большой комнаты в зависимости, например, от положения игрока в комнате, и он используется во многих играх. Вспомните, как в классических играх, таких как Mario или Zelda, взгляд всегда следует за главным героем. Это делается с помощью камер. Для получения дополнительной информации см. раздел <a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Свойства комнаты</a> в разделе "Редактор комнат" руководства.</p>
  <p>Все следующие примеры будут использовать событие <strong>Draw GUI</strong>, поэтому вам нужно будет создать объект и добавить к нему это событие. Обратите внимание, что объекту не нужно назначать <span class="notranslate">sprite</span>, так как мы не хотим рисовать что-либо по умолчанию, и нам не нужно, чтобы он обнаруживал столкновения. Подобные объекты, предназначенные только для рисования или управления определенными аспектами игры, часто называют <strong>объектами-контроллерами</strong>. Также обратите внимание, что во всех примерах мы будем использовать один и тот же объект, поэтому мы рекомендуем вам проходить их один за другим (хотя это не является строго необходимым).</p>
  <p><img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#">Текст рисунка</a></p>
  <div class="droptext" data-targetname="drop_down5">
    <p class="dropspot">При рисовании на слое GUI левый верхний угол является исходным положением, справа - +X, внизу - +Y. Это делает позиционирование текста и графики очень простым, как вы увидите в этом примере. Все, что мы собираемся сделать здесь, это нарисовать значение, которое представляет собой счет игрока, поэтому в нашем объекте нам нужно добавить <strong>событие Create Event </strong>для инициализации переменной для хранения этого значения, как показано ниже:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif" /></p>
    <p class="code">player_score = 0;</p>
    <p class="dropspot">Мы также хотим добавить к объекту <strong>событие Keyboard Down &lt;Space&gt;</strong>, поскольку мы будем использовать его для увеличения счета каждый раз, когда вы нажимаете клавишу Space.</p>
    <p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317" /></p>
    <p class="dropspot">В этом случае добавьте следующее:</p>
    <p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png" /></p>
    <p class="code">var _val = irandom(100);
      <br />
      player_score = player_score + _val;
    </p>
    <p class="dropspot">Наконец, давайте нарисуем значение оценки в событии Draw GUI, вот так:</p>
    <p class="dropspot">В этом случае добавьте следующее:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_set_halign(fa_left);
      <br />
      draw_set_colour(c_yellow);
      <br />
      draw_text(32, 32, &quot;SCORE:&quot;);
      <br />
      draw_set_colour(c_white);
      <br />
      var _str = string(player_score);
      <br />
      draw_text_transformed(32, 48, _str, 2, 2, 0);
    </p>
    <p class="dropspot">Вы заметите, что мы использовали <a class="glossterm" data-glossterm="с жестким кодом" href="#">жестко заданные</a> (или фиксированные) значения для позиции x/y рисуемого текста, поскольку нам не нужно, чтобы он был относительно какого-либо экземпляра, так как мы рисуем на слое GUI. Мы также использовали функцию &quot;set color&quot;, чтобы изменить цвет текста, а также функцию &quot;transformed&quot;, чтобы сделать фактическое значение очков больше, что иллюстрирует, как можно настраивать текстовые элементы в собственных играх.</p>
    <p class="dropspot">Добавьте один экземпляр этого объекта в комнату, а затем нажмите кнопку <strong>Play </strong> <img>. Когда игра запустится, нажмите и отпустите клавишу <span class="inline">&lt;Space&gt;</span>, и вы увидите, что значение счета увеличивается.</p>
    <p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#">Рисование спрайтов</a></p>
  <div class="droptext" data-targetname="drop_down6">
    <p class="dropspot">В этом примере мы собираемся использовать слой GUI для рисования некоторых <span class="notranslate">sprites</span>. Наиболее очевидное применение для этого - нарисовать жизни игроков, так что давайте сделаем именно это! Для этого примера вам понадобится <span class="notranslate">sprite</span>, размер которого должен быть примерно 64x64 пикселя, но его не следует назначать объекту, так как мы будем рисовать его сами.</p>
    <p class="dropspot">Для начала нам нужно добавить несколько новых переменных к объекту в <strong>событии Create</strong> (если вы делали предыдущий пример, добавьте следующие переменные ниже тех, что уже есть):</p>
    <p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png" /></p>
    <p class="code">player_lives = 3;
      <br />
      gui_w = display_get_gui_width();
    </p>
    <p class="dropspot">В этом коде мы инициализируем переменную для жизней игрока, но мы также создаем переменную для хранения ширины слоя GUI, чтобы мы могли правильно расположить все относительно правой части экрана. Мы могли бы просто ввести значение в код и использовать его, но это означало бы, что если мы изменим размер комнаты или добавим камеры и т.д., то нам придется пройтись по коду и изменить значение везде. Использование <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a> означает, что нам не нужно беспокоиться о любых будущих изменениях, так как код будет автоматически адаптироваться к любому размеру слоя GUI.</p>
    <p class="dropspot">Далее мы хотим добавить к объекту <strong>событие Keyboard Pressed &lt;Enter&gt; Event</strong>, поскольку мы будем использовать его для изменения количества жизней при каждом нажатии клавиши Enter:</p>
    <p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png" /></p>
    <p class="dropspot">В этом случае добавьте следующее:</p>
    <p class="dropspot"><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png" /></p>
    <p class="code">player_lives = player_lives - 1;
      <br />
      <br />
      if player_lives &lt; 0
      <br />
      {
      <br />
      player_lives = 3;
      <br />
      }
    </p>
    <p class="dropspot">Наконец, нам нужно нарисовать <span class="notranslate">sprites</span> на экране. Для этого мы будем использовать цикл &quot; <span class="inline">for</span>&quot; (информация об использовании <span class="notranslate">GML</span> <a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">здесь</a>, а для <span class="notranslate">GML</span> Visual <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">здесь</a>), а также переменную GUI width, чтобы расположить все в правом верхнем углу экрана. Итак, добавьте это в событие Draw Gui Event (после любых других действий, которые могли быть в предыдущих примерах):</p>
    <p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png" /></p>
    <p class="code">for (var i = 0; i &lt; player_lives; i += 1)
      <br />
      {
      <br />
      var _xx = gui_w - 48 - (i * 70);
      <br />
      draw_sprite(spr_Heart, 0, _xx, 48);
      <br />
      }
    </p>
    <p class="dropspot">Если вы еще не добавили экземпляр этого объекта в комнату, добавьте его сейчас (только один!), а затем нажмите кнопку <strong>Play </strong> <img>. После запуска игры нажимайте клавишу <span class="inline">&lt;Enter&gt;</span> несколько раз, чтобы увидеть, как меняются жизни.</p>
    <p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="dropspot">Прежде чем оставить этот пример, поэкспериментируйте с количеством жизней и посмотрите, что получится. Сейчас оно установлено на 3, но измените событие Create и событие Key Pressed, чтобы установить значение на 5, или 10... если вы все сделали правильно, то код должен адаптироваться и нарисовать их все правильно!</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#">Рисование панели здоровья</a></p>
  <div class="droptext" data-targetname="drop_down7">
    <p class="dropspot">Последний пример посвящен рисованию панели здоровья на слое GUI. Это можно сделать разными способами, но в <span data-keyref="GameMaker Name">GameMaker</span> есть встроенная функция, специально предназначенная для создания полос здоровья, поэтому мы будем использовать именно ее, хотя вы можете создать свою собственную, используя <span class="notranslate">sprites</span> или фигуры. Для начала, как и раньше, нам нужно инициализировать переменную для хранения значения здоровья, поэтому добавьте следующий <span class="notranslate">GML</span> Visual или <span class="notranslate">GML</span> в <strong>событие Create</strong> объекта (после любого другого кода, который уже может там быть):</p>
    <p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png" /></p>
    <p class="code">player_health = 100;</p>
    <p class="dropspot">Мы хотим использовать клавиши со стрелками для изменения значения здоровья вверх или вниз в зависимости от того, какая клавиша со стрелкой нажата, и мы могли бы сделать это, добавив два события <strong>Keyboard Pressed &lt;Arrow&gt;</strong>, однако, вероятно, проще использовать <strong>событие Step Event</strong> и некоторый код для проверки наличия клавиш, поэтому давайте добавим <strong>событие Step Event</strong> сейчас с помощью следующего <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png" /></p>
    <p class="code">if keyboard_check(vk_up)<br />
      {<br />
          if (player_health &lt; 100) <br />
          {<br />
              player_health = player_health + 1;<br />
          }<br />
      }<br />
      <br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          if (player_health &gt; 0) <br />
          {<br />
              player_health = player_health - 1;<br />
          }<br />
      }
    </p>
    <p class="dropspot">После этого мы можем приступить к рисованию панели здоровья, что делается в событии Draw GUI, добавляя следующее (после всего остального, что уже есть):</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _xx = display_get_gui_width() / 2;<br />
      <br />
      draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);
    </p>
    <p class="dropspot">Добавьте экземпляр этого объекта в комнату, если вы еще не сделали этого (только один!), а затем нажмите кнопку <strong>Play </strong> <img>. После запуска игры нажимайте клавиши <span class="inline">&lt;Up Arrow&gt;</span> и <span class="inline">&lt;Down Arrow&gt;</span> несколько раз, чтобы увидеть, как меняется здоровье.</p>
    <p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif" /></p>
  </div>
  <p> </p>
  <p>Мы надеемся, что после выполнения этих примеров у вас появится больше уверенности при использовании <span data-keyref="GameMaker Name">GameMaker</span> и больше понимания того, как все это работает. В следующем разделе мы рассмотрим, как заставить нарисованные вами объекты перемещаться по комнате, а также принимать пользовательский ввод и реагировать на него.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="../Content.htm">Указатель</a></div>
        <div style="float:right">Следующее: <a href="Movement_And_Controls.htm">Движение и управление</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Drawing
Drawing Examples
Quick Start Drawing
-->
  <!-- TAGS
qs_drawing
-->
</body>
</html>