<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Движение и управление</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Движение и управление</h1>
  <p>В <a href="Drawing.htm">предыдущем разделе</a> этого краткого руководства были приведены примеры рисования объектов на экране, но просто рисовать объекты не очень хорошо, если вы не можете их перемещать... поэтому в этом разделе мы приведем несколько примеров перемещения объектов, а также несколько основных схем управления для различных типов игр. Все примеры приведены с использованием <span class="notranslate">GML</span> Visual, а также <span class="notranslate">GML</span> Code, поэтому вы можете использовать тот вариант, с которым вам удобнее работать. Обратите внимание, что мы не будем объяснять здесь все слишком подробно, поскольку мы хотим, чтобы вы как можно быстрее приступили к созданию вещей, поэтому мы рекомендуем вам изучать все ссылки по ходу работы и использовать функцию &quot;поиск&quot; в руководстве для поиска дополнительной информации о том, в чем вы не уверены.</p>
  <p>Прежде чем двигаться дальше, вы, возможно, захотите создать новый проект (либо <span class="notranslate">GML</span>, либо <span class="notranslate">GML</span> Visual) на <a href="../Introduction/The_Start_Page.htm">Стартовой странице</a>, добавить (или создать) несколько <span class="notranslate">sprites</span>, а также объект или два - поскольку мы дадим вам некоторый код, который вы сможете протестировать с их помощью - и убедиться, что в проекте есть комната для размещения экземпляров. Не слишком заботьтесь о том, как выглядит созданный вами <span class="notranslate">sprites</span>, так как подойдет даже простой белый квадрат, и как только вы все подготовите, можете приступать к работе над примерами, перечисленными ниже.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Двигайтесь по направлению к мыши</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Одним из самых простых способов заставить объект двигаться и взаимодействовать с игроком является использование мыши, и в этом примере мы покажем вам, как с помощью базового кода заставить объект двигаться туда, где пользователь нажал левую кнопку мыши <img>.</p>
    <p class="dropspot">Для начала откройте объект, присвойте ему адрес <span class="notranslate">sprite</span>, а затем назначьте ему <strong>глобальное событие Left Mouse Down</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Мы используем <strong>глобальные </strong>события мыши, потому что они обнаруживают щелчок в любом месте комнаты, в то время как обычные события мыши обнаруживают щелчок только в том случае, если мышь действительно щелкает в пределах <a class="glossterm" data-glossterm="ограничительная рамка" href="#">ограничительной области</a> экземпляра. В это событие мы хотим добавить следующие действия или код:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Здесь мы указываем экземпляру двигаться к позиции на экране, в данном случае к позиции &quot;<span class="inline">mouse_x</span>&quot; и &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; и &quot;<span class="inline">mouse_y</span>&quot; являются <strong>встроенными </strong> <a class="glossterm" data-glossterm="переменная" href="#">переменными</a>, которые всегда хранят текущую позицию курсора мыши). Визуал <span class="notranslate">GML</span> делает это путем установки &quot;<span class="inline">direction</span>&quot; и &quot; <span class="inline">speed</span>&quot; <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Переменные экземпляра</strong></a>, в то время как <span class="notranslate">GML</span> делает это с помощью функции <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (она также устанавливает переменные <span class="inline">speed </span>и <span class="inline">direction </span>, только в одной, простой в использовании функции).</p>
    <p class="dropspot">Поместите экземпляр этого объекта в комнату и нажмите кнопку Play <img>, затем щелкните <img> по комнате, чтобы заставить объект двигаться в направлении мыши:</p>
    <p class="dropspot"><img>Отлично! Экземпляр объекта теперь перемещается в направлении того места, где вы щелкнули мышью, и если вы удерживаете кнопку нажатой, экземпляр будет просто следовать за курсором мыши. Однако есть проблема... После того, как вы щелкните один раз и отпустите кнопку, объект продолжит движение и в конце концов покинет комнату! Есть несколько способов исправить это, и выбор того или иного зависит от того, что вы хотите сделать, но самым простым на данный момент является простое добавление события <strong>Global Mouse Button Released</strong>, поэтому добавьте его к объекту и дайте ему следующий код:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">При этом экземпляр будет следовать за курсором мыши только до тех пор, пока удерживается кнопка мыши, а когда вы отпустите кнопку, он перестанет двигаться. Нажмите Play <img> и протестируйте его прямо сейчас.</p>
    <p class="dropspot">Прежде чем мы оставим этот пример, необходимо решить еще один вопрос... Если нажать и <em>удерживать </em>кнопку мыши, но не перемещать курсор, то экземпляр будет двигаться к курсору, а затем &quot;вибрировать&quot; вокруг него. Это происходит потому, что экземпляр движется быстрее, чем на 1 пиксель за раз, и поэтому &quot;перебегает&quot; позицию, а затем пытается вернуться назад, затем снова перебегает и т.д... (сделайте скорость движения 5 или что-то вроде этого, чтобы увидеть проблему, если она не очевидна сразу).</p>
    <p class="dropspot"><img>Чтобы решить эту проблему, нам нужно добавить <strong>событие Step Event</strong> к объекту с помощью этого кода:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if (_dist &lt;= speed) <br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Здесь мы просто проверяем расстояние от экземпляра до позиции мыши, и если оно равно или меньше текущей скорости, мы устанавливаем скорость на 0. Это заставляет экземпляр останавливаться, когда он достаточно близко к позиции мыши, и мы не получаем этой неприятной проблемы &quot;вибрации&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">4-х и 8-ми стороннее движение с помощью клавиатуры</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot">В<a href="What_Is_Programming_.htm">самом начале этого руководства</a> мы показали вам следующее действие и код для перемещения экземпляра вправо на два пикселя каждый игровой шаг:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Этот тип перемещения называется <strong>позиционным </strong>, поскольку мы, по сути, поднимаем экземпляр и помещаем его в новое положение каждый раз, когда выполняется код. В этом примере мы покажем, как использовать этот тип движения для перемещения экземпляра в четырех направлениях: вверх, вниз, влево и вправо.</p>
    <p class="dropspot">Для начала откройте объект и присвойте ему адрес <span class="notranslate">sprite</span>. Теперь мы могли бы добавить различные <strong>события клавиатуры</strong> в этот момент и в каждом из них заставить экземпляр двигаться в нужном направлении, однако мы хотим, чтобы игрок мог двигаться только в одном направлении за раз, и сделать это с помощью только событий клавиатуры немного сложнее, чем с помощью кода. Вместо этого мы будем использовать <strong>событие Step Event</strong> - которое вы должны добавить сейчас к объекту - со следующими действиями или кодом, чтобы использовать клавиши со стрелками для перемещения:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Мы используем структуру &quot; <span class="inline">if... else if... else if...</span>&quot;, чтобы гарантировать, что объект будет двигаться только в одном направлении за один раз, поэтому объект должен иметь возможность двигаться только вверх, вниз, влево или вправо, но не по диагонали. Поместите экземпляр объекта в комнату и нажмите кнопку <strong>Play </strong> <img>, чтобы протестировать его прямо сейчас! Если все прошло правильно, у вас должно получиться что-то вроде этого:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Мы можем легко модифицировать этот код для преобразования 4-стороннего движения в 8-стороннее... просто удалите команды &quot; <span class="inline">else</span>&quot; из блоков кода, чтобы все выглядело следующим образом:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Теперь, когда вы нажмете кнопку <strong>Play </strong> <img>, это будет выглядеть примерно так:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">И последнее, на что стоит обратить внимание пользователям, кодирующим с помощью <span class="notranslate">GML</span>... При использовании <span class="notranslate">GML</span> Visual вы можете выбрать клавишу клавиатуры, которую вы хотите использовать, из выпадающего списка, но с <span class="notranslate">GML</span> все не так просто. Существует ряд <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">констант клавиатуры</a>, которые вы можете использовать - например, константы клавиш со стрелками, показанные в коде выше, - но <em>нет </em>констант для буквенно-цифровых клавиш. Они обрабатываются несколько иначе и требуют использования функции <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. В приведенном ниже коде показано, как это будет работать, если вместо клавиш со стрелками использовать WASD:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;D&quot;))) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;W&quot;))) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;S&quot;))) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Движение геймпада</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Мы рассмотрели движение мыши и клавиатуры, а значит, пришло время рассказать о движении <strong>геймпада </strong>. Теперь мы не будем рассматривать d-pad, поскольку он работает точно так же, как и клавиатура (просто замените функции клавиатуры в примере выше на <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> или <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">If Gamepad button Down</a>), поэтому в этом примере мы рассмотрим использование аналогового стика для перемещения.</p>
    <p class="dropspot">Для начала нам нужно определить используемый геймпад. Геймпадам присваивается значение ID от 0 до 11, поэтому мы будем использовать цикл &quot; <span class="inline">for</span>&quot; для определения ID всех подключенных геймпадов и сохранения этого значения ID в переменной для дальнейшего использования. Поскольку мы хотим определить только первый подключенный геймпад, а не все, мы будем использовать команду &quot; <span class="inline">break</span>&quot; после обнаружения геймпада, чтобы он &quot;прервал&quot; цикл (например, если первый подключенный геймпад имеет ID 4, то цикл будет выполняться только 5 раз, проверяя значения ID 0 - 4, а затем выходя из цикла при обнаружении геймпада). Итак, создайте (или откройте) объект, присвойте ему <span class="notranslate">sprite</span>, а затем добавьте <strong>событие Create Event</strong> со следующими параметрами:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if (gamepad_is_connected(i)) <br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Обратите внимание, что в приведенном выше коде мы установили <strong> <a class="glossterm" data-glossterm="мертвая зона" href="#">deadzone</a> </strong>для геймпада. Это связано с тем, что аналоговые стики на разных моделях геймпадов имеют разную чувствительность, и иногда они могут быть настолько чувствительными, что если не установить мертвую зону, то они могут вызывать нежелательные движения в играх. Поэтому мы устанавливаем мертвую зону на значение 0,2, чтобы указать <span data-keyref="GameMaker Name">GameMaker</span> игнорировать любые значения стиков геймпада ниже этого <a class="glossterm" data-glossterm="абсолютный" href="#">абсолютного</a> значения.</p>
    <p class="dropspot">Чтобы добавить фактическое движение, нам понадобится <strong>событие Step Event</strong>, поэтому добавьте его сейчас и дайте ему следующий адрес <span class="notranslate">GML</span> Visual или GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepads[0], gp_axislh);<br />
          var _v = gamepad_axis_value(gamepads[0], gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Здесь мы проверяем <em>левый </em>стик на горизонтальное или вертикальное движение. Функции оси возвращают значение между -1 и 1, поэтому для горизонтальной оси -1 - это движение влево, 0 - не движение и 1 - движение вправо, а для вертикальной оси -1 - вверх, 0 - не движение и 1 - вниз. Обратите внимание, что значения находятся в диапазоне <em>от </em>-1 до 1, поэтому, например, горизонтальная ось может вернуть значение 0,5, что означает, что стик находится на полпути между положением &quot;покоя&quot; и полным отклонением вправо. По этой причине мы умножаем значение на 4 (на самом деле можно умножать на любое значение, в зависимости от скорости, с которой должен двигаться экземпляр) - это означает, что скорость экземпляра будет меняться в зависимости от того, насколько сильно было сделано движение по оси стика.</p>
    <p class="dropspot">Поместите экземпляр этого объекта в комнату и нажмите кнопку <strong>Play </strong>. <strong> <img></strong>а затем передвигайтесь с помощью левого стика подключенного геймпада. Вы должны увидеть что-то вроде этого:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Усовершенствованное 8-стороннее движение</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">В этом последнем примере мы рассмотрим наш код 8-стороннего движения и решим проблему, которая заключается в том, что диагональное движение на самом деле быстрее, чем движение вверх/вниз/влево/вправо. Это происходит потому, что при движении по диагонали вы двигаетесь вдоль гипотенузы прямоугольного треугольника, созданного значениями перемещений x/y:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Чтобы было понятнее, что происходит, давайте уберем весь текст и <span class="notranslate">sprites</span> и просто покажем ту же линию движения, повернутую на 45°, чтобы она была горизонтальной:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Как видите, разница довольно очевидна, а если экземпляр перемещается более чем на 1-2 пикселя за шаг, то становится очень заметно, что диагональное движение <em>намного </em>быстрее! Как же это ограничить? Есть несколько способов сделать это, но мы остановимся только на одном из них, потому что он вводит несколько функций и концепций, которые пригодятся вам позже в ваших играх.</p>
    <p class="dropspot">Чтобы справиться с этим, нам придется хранить входные значения от нажатых клавиш независимо друг от друга в <a class="glossterm" data-glossterm="переменная" href="#">переменных</a>, а затем проверять их и перемещаться в соответствии с комбинацией нажатых клавиш. Итак, для этого вам понадобится объект с назначенным <span class="notranslate">sprite</span>, и вам нужно будет дать ему <strong>событие Step Event</strong> со следующими действиями или кодом:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Мы разделили визуальные действия выше на две колонки, чтобы их было легче визуализировать, но в визуальном редакторе они будут располагаться последовательно.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Нам нужно будет добавить еще немного кода для реального перемещения, но прежде давайте немного объясним это. Мы хотим преобразовать движения влево/вправо/вверх/вниз в эквивалентные значения скорости по горизонтали и вертикали, поэтому для этого мы получаем значение каждой клавиши, а затем выполняем некоторые основные математические операции, чтобы получить значения скорости. Это работает потому, что если клавиша нажата, то действие или функция проверки вернет &quot;1&quot;, а если она <em>не </em>нажата, то функция вернет 0. Так, например, если нажата правая клавиша, то для &quot; <span class="inline">_hspd</span>&quot; вы получите &quot;1 - 0 = 1&quot;, а если левая, то для &quot; <span class="inline">_hspd</span>&quot; вы получите &quot;0 - 1 = -1&quot; (а если они обе нажаты, то будет &quot;1 - 1 = 0&quot;, так что экземпляр не будет двигаться). Помните, что в комнате <span data-keyref="GameMaker Name">GameMaker</span> для перемещения вправо мы прибавляем к позиции <span class="inline">x </span>, а для перемещения влево - вычитаем, поэтому этот код даст нам положительное или отрицательное значение, которое мы можем прибавить или вычесть для перемещения по горизонтали или вертикали в зависимости от клавиатурного ввода.</p>
    <p class="dropspot">Теперь мы можем добавить код, который фактически перемещает экземпляр, поэтому - все еще в <strong>событии Step Event</strong>, и после вышеуказанного кода - добавьте следующее:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">Приведенный выше код сначала проверяет, истинно ли одно из двух <a class="glossterm" data-glossterm="выражение" href="#">выражений</a>, т.е. не равны ли 0 переменные горизонтальной или вертикальной скорости. Обратите внимание, что в проверке &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> используется символ &quot; <span class="inline">||</span>&quot;. В программировании это означает &quot; <span class="inline">or</span>&quot;, поэтому - на простом языке - вы проверяете</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">Таким образом можно объединить несколько выражений в проверки &quot; <span class="inline">if</span>&quot;, и существует несколько различных способов оценки этих выражений (для получения дополнительной информации см. раздел &quot; <strong>Выражения&quot;</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">здесь</a>).</p>
    <p class="dropspot">Следующий раздел кода хранит значение фактической скорости движения в переменной, а затем получает направление, используя значения <span class="inline">_hspd </span>и <span class="inline">_vspd </span>, которые могут быть -1, 0 или 1. Функция направления проверяет направление от (0, 0), так как мы не используем комнатные координаты, а хотим, чтобы она оценивала направление от 0° до 360° на основе значений переменных. Следующая диаграмма иллюстрирует происходящее лучше, чем попытка объяснить это словами:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">ПРИМЕЧАНИЕ</span> Направление в <span data-keyref="GameMaker Name">GameMaker</span> рассчитывается <strong>против часовой стрелки</strong>, поэтому 0° и 360° находятся справа, 90° - вверх, 180° - вправо и 270° - вниз.</p>
    <p class="dropspot">Наконец, мы используем <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> и <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> для фактического перемещения переменной. Это <strong> <a class="glossterm" data-glossterm="вектор" href="#">вектор</a>  </strong>функции, которые принимают длину (расстояние) и направление, а затем вычисляют новое положение на заданной оси на основе этих значений (более подробное объяснение см. в описании функций).</p>
    <p class="dropspot">Это очень много, и не волнуйтесь, если вы еще не все поняли! Со временем вы поймете! Теперь осталось только добавить экземпляр этого объекта в комнату, а затем нажать кнопку <strong>Play </strong>. <strong> <img></strong>и вы получите шелковисто-гладкое движение в 8 направлениях без каких-либо проблем, связанных с движением по диагонали:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Мы надеемся, что эти примеры - и предыдущие примеры для рисования - достаточно понятны, чтобы начать создавать свои собственные проекты! На последней странице этого Краткого руководства вы найдете краткое изложение того, что вы узнали, а также ссылки на дополнительные учебные материалы.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="../Content.htm">Указатель</a></div>
        <div style="float:right">Следующее: <a href="Summary.htm">Резюме</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>